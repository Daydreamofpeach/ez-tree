{"version":3,"file":"@dgreenheck-tree-js.umd.js","sources":["../src/rng.js","../src/branch.js","../src/enums.js","../src/treeParams.js","../src/tree.js"],"sourcesContent":["export default class RNG {\n  m_w = 123456789;\n  m_z = 987654321;\n  mask = 0xffffffff;\n\n  constructor(seed) {\n    this.m_w = (123456789 + seed) & this.mask;\n    this.m_z = (987654321 - seed) & this.mask;\n  }\n\n  /**\n   * Returns a random number between min and max\n   */\n  random(max = 1, min = 0) {\n    this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & this.mask;\n    this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & this.mask;\n    let result = ((this.m_z << 16) + (this.m_w & 65535)) >>> 0;\n    result /= 4294967296;\n\n    return (max - min) * result + min;\n  }\n}\n","import * as THREE from 'three';\n\nexport class Branch {\n  /**\n   * Generates a new branch\n   * @param {THREE.Vector3} origin The starting point of the branch\n   * @param {THREE.Euler} orientation The starting orientation of the branch\n   * @param {number} length The length of the branch\n   * @param {number} radius The radius of the branch at its starting point\n   */\n  constructor(\n    origin = new THREE.Vector3(),\n    orientation = new THREE.Euler(),\n    length = 0,\n    radius = 0,\n    level = 0,\n    sectionCount = 0,\n    segmentCount = 0,\n  ) {\n    this.origin = origin.clone();\n    this.orientation = orientation.clone();\n    this.length = length;\n    this.radius = radius;\n    this.level = level;\n    this.sectionCount = sectionCount;\n    this.segmentCount = segmentCount;\n  }\n}\n","export const BarkType = {\n  Birch: 'birch',\n  Oak: 'oak',\n  Pine: 'pine',\n  Willow: 'willow'\n};\n\nexport const Billboard = {\n  Single: 'single',\n  Double: 'double',\n};\n\nexport const LeafType = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Beech: 'beech',\n  Evergreen: 'evergreen',\n  Oak: 'oak',\n};\n\nexport const TreeType = {\n  Deciduous: 'deciduous',\n  Evergreen: 'evergreen',\n};","import { BarkType, Billboard, LeafType, TreeType } from './enums'\n\nexport const TreeParams = {\n  seed: 0,\n  type: TreeType.Deciduous,\n\n  // Bark parameters\n  bark: {\n    // The bark texture\n    type: BarkType.Oak,\n\n    // Tint of the tree trunk\n    tint: 0xffffff,\n\n    // Use face normals for shading instead of vertex normals\n    flatShading: false,\n\n    // Apply texture to bark\n    textured: true,\n\n    // Scale for the texture\n    textureScale: { x: 1, y: 1 }\n  },\n\n  // Branch parameters\n  branch: {\n    // Number of branch recursion levels. 0 = trunk only\n    levels: 3,\n\n    // Angle of the child branches relative to the parent branch (degrees)\n    angle: {\n      1: 70,\n      2: 60,\n      3: 60\n    },\n\n    // Number of children per branch level\n    children: {\n      0: 7,\n      1: 7,\n      2: 5\n    },\n\n    // External force encouraging tree growth in a particular direction\n    force: {\n      direction: { x: 0, y: 1, z: 0 },\n      strength: 0.01,\n    },\n\n    // Amount of curling/twisting  at each branch level\n    gnarliness: {\n      0: 0.15,\n      1: 0.2,\n      2: 0.3,\n      3: 0.02,\n    },\n\n    // Length of each branch level\n    length: {\n      0: 20,\n      1: 20,\n      2: 10,\n      3: 1\n    },\n\n    // Radius of each branch level\n    radius: {\n      0: 1.5,\n      1: 0.7,\n      2: 0.7,\n      3: 0.7\n    },\n\n    // Number of sections per branch level\n    sections: {\n      0: 12,\n      1: 10,\n      2: 8,\n      3: 6,\n    },\n\n    // Number of radial segments per branch level\n    segments: {\n      0: 8,\n      1: 6,\n      2: 4,\n      3: 3,\n    },\n\n    // Defines where child branches start forming on the parent branch\n    start: {\n      1: 0.4,\n      2: 0.3,\n      3: 0.3\n    },\n\n    // Taper at each branch level\n    taper: {\n      0: 0.7,\n      1: 0.7,\n      2: 0.7,\n      3: 0.7,\n    },\n\n    // Amount of twist at each branch level\n    twist: {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 0,\n    },\n  },\n\n  // Leaf parameters\n  leaves: {\n    // Leaf texture to use\n    type: LeafType.Oak,\n\n    // Whether to use single or double/perpendicular billboards\n    billboard: Billboard.Double,\n\n    // Angle of leaves relative to parent branch (degrees)\n    angle: 10,\n\n    // Number of leaves\n    count: 1,\n\n    // Where leaves start to grow on the length of the branch (0 to 1)\n    start: 0,\n\n    // Size of the leaves\n    size: 2.5,\n\n    // Variance in leaf size between each instance\n    sizeVariance: 0.7,\n\n    // Tint color for the leaves\n    tint: 0xffffff,\n\n    // Controls transparency of leaf texture\n    alphaTest: 0.5,\n  },\n};","import * as THREE from 'three';\nimport RNG from './rng';\nimport { Branch } from './branch';\nimport { Billboard, TreeType } from './enums';\nimport { TreeParams } from './treeParams';\nimport * as textures from './textures/index.json';\n\nconst textureCache = {};\n\nconst textureLoader = new THREE.TextureLoader();\nconst loadTexture = (path, scale = { x: 1, y: 1 }, colorSpace = null) => {\n  if (!textureCache[path]) {\n    const url = new URL(path, import.meta.url).href;\n    textureCache[path] = textureLoader.load(url);\n  }\n\n  /**\n   * @type {THREE.Texture}\n   */\n  const texture = textureCache[path];\n  texture.wrapS = THREE.MirroredRepeatWrapping;\n  texture.wrapT = THREE.MirroredRepeatWrapping;\n  texture.repeat.x = scale.x;\n  texture.repeat.y = 1 / scale.y;\n\n  if (colorSpace) {\n    texture.colorSpace = colorSpace;\n    texture.premultiplyAlpha = true;\n  }\n\n  return texture;\n};\n\nexport class Tree extends THREE.Group {\n  /**\n   * @type {RNG}\n   */\n  rng;\n\n  /**\n   * @type {TreeParams}\n   */\n  params;\n\n  /**\n   * @type {Branch[]}\n   */\n  branchQueue = [];\n\n  /**\n   * @param {TreeParams} params\n   */\n  constructor(params = TreeParams) {\n    super();\n    this.params = params;\n    this.branchesMesh = new THREE.Mesh();\n    this.leavesMesh = new THREE.Mesh();\n    this.add(this.branchesMesh);\n    this.add(this.leavesMesh);\n  }\n\n  /**\n   * Generate a new tree\n   */\n  generate() {\n    // Clean up old geometry\n    this.branches = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.leaves = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.rng = new RNG(this.params.seed);\n\n    // Create the trunk of the tree first\n    this.branchQueue.push(\n      new Branch(\n        new THREE.Vector3(),\n        new THREE.Euler(),\n        this.params.branch.length[0],\n        this.params.branch.radius[0],\n        0,\n        this.params.branch.sections[0],\n        this.params.branch.segments[0],\n      ),\n    );\n\n    while (this.branchQueue.length > 0) {\n      const branch = this.branchQueue.shift();\n      this.generateBranch(branch);\n    }\n\n    this.createBranchesGeometry();\n    this.createLeavesGeometry();\n  }\n\n  /**\n   * Generates a new branch\n   * @param {Branch} branch\n   * @returns\n   */\n  generateBranch(branch) {\n    // Used later for geometry index generation\n    const indexOffset = this.branches.verts.length / 3;\n\n    let sectionOrientation = branch.orientation.clone();\n    let sectionOrigin = branch.origin.clone();\n    let sectionLength =\n      branch.length /\n      branch.sectionCount /\n      (this.params.type === 'Deciduous' ? this.params.branch.levels - 1 : 1);\n\n    // This information is used for generating child branches after the branch\n    // geometry has been constructed\n    let sections = [];\n\n    for (let i = 0; i <= branch.sectionCount; i++) {\n      let sectionRadius = branch.radius;\n\n      // If final section of final level, set radius to effecively zero\n      if (\n        i === branch.sectionCount &&\n        branch.level === this.params.branch.levels\n      ) {\n        sectionRadius = 0.001;\n      } else if (this.params.type === TreeType.Deciduous) {\n        sectionRadius *=\n          1 - this.params.branch.taper[branch.level] * (i / branch.sectionCount);\n      } else if (this.params.type === TreeType.Evergreen) {\n        // Evergreens do not have a terminal branch so they have a taper of 1\n        sectionRadius *= 1 - (i / branch.sectionCount);\n      }\n\n      // Create the segments that make up this section.\n      let first;\n      for (let j = 0; j < branch.segmentCount; j++) {\n        let angle = (2.0 * Math.PI * j) / branch.segmentCount;\n\n        // Create the segment vertex\n        const vertex = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .multiplyScalar(sectionRadius)\n          .applyEuler(sectionOrientation)\n          .add(sectionOrigin);\n\n        const normal = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .applyEuler(sectionOrientation)\n          .normalize();\n\n        const uv = new THREE.Vector2(\n          j / branch.segmentCount,\n          (i % 2 === 0) ? 0 : 1,\n        );\n\n        this.branches.verts.push(...Object.values(vertex));\n        this.branches.normals.push(...Object.values(normal));\n        this.branches.uvs.push(...Object.values(uv));\n\n        if (j === 0) {\n          first = { vertex, normal, uv };\n        }\n      }\n\n      // Duplicate the first vertex so there is continuity in the UV mapping\n      this.branches.verts.push(...Object.values(first.vertex));\n      this.branches.normals.push(...Object.values(first.normal));\n      this.branches.uvs.push(1, first.uv.y);\n\n      // Use this information later on when generating child branches\n      sections.push({\n        origin: sectionOrigin.clone(),\n        orientation: sectionOrientation.clone(),\n        radius: sectionRadius,\n      });\n\n      sectionOrigin.add(\n        new THREE.Vector3(0, sectionLength, 0).applyEuler(sectionOrientation),\n      );\n\n      // Perturb the orientation of the next section randomly. The higher the\n      // gnarliness, the larger potential perturbation\n      const gnarliness =\n        Math.max(1, 1 / Math.sqrt(sectionRadius)) *\n        this.params.branch.gnarliness[branch.level];\n\n      sectionOrientation.x += this.rng.random(gnarliness, -gnarliness);\n      sectionOrientation.z += this.rng.random(gnarliness, -gnarliness);\n\n      // Apply growth force to the branch\n      const qSection = new THREE.Quaternion().setFromEuler(sectionOrientation);\n\n      const qTwist = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        this.params.branch.twist[branch.level],\n      );\n\n      const qForce = new THREE.Quaternion().setFromUnitVectors(\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3().copy(this.params.branch.force.direction),\n      );\n\n      qSection.multiply(qTwist);\n      qSection.rotateTowards(\n        qForce,\n        this.params.branch.force.strength / sectionRadius,\n      );\n\n      sectionOrientation.setFromQuaternion(qSection);\n    }\n\n    this.generateBranchIndices(indexOffset, branch);\n\n    // Deciduous trees have a terminal branch that grows out of the\n    // end of the parent branch\n    if (this.params.type === 'deciduous') {\n      const lastSection = sections[sections.length - 1];\n\n      if (branch.level < this.params.branch.levels) {\n        this.branchQueue.push(\n          new Branch(\n            lastSection.origin,\n            lastSection.orientation,\n            this.params.branch.length[branch.level + 1],\n            lastSection.radius,\n            branch.level + 1,\n            // Section count and segment count must be same as parent branch\n            // since the child branch is growing from the end of the parent branch\n            branch.sectionCount,\n            branch.segmentCount,\n          ),\n        );\n      } else {\n        this.generateLeaf(lastSection.origin, lastSection.orientation);\n      }\n    }\n\n    // If we are on the last branch level, generate leaves\n    if (branch.level === this.params.branch.levels) {\n      this.generateLeaves(sections);\n    } else if (branch.level < this.params.branch.levels) {\n      this.generateChildBranches(\n        this.params.branch.children[branch.level],\n        branch.level + 1,\n        sections);\n    }\n  }\n\n  /**\n   * Generate branches from a parent branch\n   * @param {number} count The number of child branches to generate\n   * @param {number} level The level of the child branches\n   * @param {{\n   *  origin: THREE.Vector3,\n   *  orientation: THREE.Euler,\n   *  radius: number\n   * }[]} sections The parent branch's sections\n   * @returns\n   */\n  generateChildBranches(count, level, sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < count; i++) {\n      // Determine how far along the length of the parent branch the child\n      // branch should originate from (0 to 1)\n      let childBranchStart = this.rng.random(1.0, this.params.branch.start[level]);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(childBranchStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (childBranchStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const childBranchOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearly interpolate radius\n      const childBranchRadius =\n        this.params.branch.radius[level] *\n        ((1 - alpha) * sectionA.radius + alpha * sectionB.radius);\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.params.branch.angle[level] / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const childBranchOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      let childBranchLength =\n        this.params.branch.length[level] *\n        (this.params.type === TreeType.Evergreen\n          ? 1.0 - childBranchStart\n          : 1.0);\n\n      this.branchQueue.push(\n        new Branch(\n          childBranchOrigin,\n          childBranchOrientation,\n          childBranchLength,\n          childBranchRadius,\n          level,\n          this.params.branch.sections[level],\n          this.params.branch.segments[level],\n        ),\n      );\n    }\n  }\n\n  /**\n   * Logic for spawning child branches from a parent branch's section\n   * @param {{\n  *  origin: THREE.Vector3,\n  *  orientation: THREE.Euler,\n  *  radius: number\n  * }[]} sections The parent branch's sections\n  * @returns\n  */\n  generateLeaves(sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < this.params.leaves.count; i++) {\n      // Determine how far along the length of the parent\n      // branch the leaf should originate from (0 to 1)\n      let leafStart = this.rng.random(1.0, this.params.leaves.start);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(leafStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (leafStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const leafOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / this.params.leaves.count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.params.leaves.angle / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const leafOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      this.generateLeaf(leafOrigin, leafOrientation);\n    }\n  }\n\n  /**\n * Generates a leaves\n * @param {THREE.Vector3} origin The starting point of the branch\n * @param {THREE.Euler} orientation The starting orientation of the branch\n */\n  generateLeaf(origin, orientation) {\n    let i = this.leaves.verts.length / 3;\n\n    // Width and length of the leaf quad\n    let leafSize =\n      this.params.leaves.size *\n      (1 +\n        this.rng.random(\n          this.params.leaves.sizeVariance,\n          -this.params.leaves.sizeVariance,\n        ));\n\n    const W = leafSize;\n    const L = 1.5 * leafSize;\n\n    const createLeaf = (rotation) => {\n      // Create quad vertices\n      const v = [\n        new THREE.Vector3(-W / 2, L, 0),\n        new THREE.Vector3(-W / 2, 0, 0),\n        new THREE.Vector3(W / 2, 0, 0),\n        new THREE.Vector3(W / 2, L, 0),\n      ].map((v) =>\n        v\n          .applyEuler(new THREE.Euler(0, rotation, 0))\n          .applyEuler(orientation)\n          .add(origin),\n      );\n\n      this.leaves.verts.push(\n        v[0].x,\n        v[0].y,\n        v[0].z,\n        v[1].x,\n        v[1].y,\n        v[1].z,\n        v[2].x,\n        v[2].y,\n        v[2].z,\n        v[3].x,\n        v[3].y,\n        v[3].z,\n      );\n\n      const n = new THREE.Vector3(0, 0, 1).applyEuler(orientation);\n      this.leaves.normals.push(\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n      );\n      this.leaves.uvs.push(0, 1, 0, 0, 1, 0, 1, 1);\n      this.leaves.indices.push(i, i + 1, i + 2, i, i + 2, i + 3);\n      i += 4;\n    };\n\n    createLeaf(0);\n    if (this.params.leaves.billboard === Billboard.Double) {\n      createLeaf(Math.PI / 2);\n    }\n  }\n\n  /**\n   * Generates the indices for branch geometry\n   * @param {Branch} branch\n   */\n  generateBranchIndices(indexOffset, branch) {\n    // Build geometry each section of the branch (cylinder without end caps)\n    let v1, v2, v3, v4;\n    const N = branch.segmentCount + 1;\n    for (let i = 0; i < branch.sectionCount; i++) {\n      // Build the quad for each segment of the section\n      for (let j = 0; j < branch.segmentCount; j++) {\n        v1 = indexOffset + i * N + j;\n        // The last segment wraps around back to the starting segment, so omit j + 1 term\n        v2 = indexOffset + i * N + (j + 1);\n        v3 = v1 + N;\n        v4 = v2 + N;\n        this.branches.indices.push(v1, v3, v2, v2, v3, v4);\n      }\n    }\n  }\n\n  /**\n   * Generates the geometry for the branches\n   */\n  createBranchesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.branches.verts), 3),\n    );\n    g.setAttribute(\n      'normal',\n      new THREE.BufferAttribute(new Float32Array(this.branches.normals), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.branches.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.branches.indices), 1),\n    );\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'branches',\n      flatShading: this.params.bark.flatShading,\n      color: this.params.bark.tint,\n    });\n\n    this.branchesMesh.geometry.dispose();\n    this.branchesMesh.geometry = g;\n    this.branchesMesh.material.dispose();\n    this.branchesMesh.material = mat;\n    this.branchesMesh.castShadow = true;\n    this.branchesMesh.receiveShadow = true;\n\n    if (this.params.bark.textured) {\n      const scale = this.params.bark.textureScale;\n      this.branchesMesh.material.aoMap = loadTexture(textures.bark[this.params.bark.type].ao, scale);\n      this.branchesMesh.material.map = loadTexture(textures.bark[this.params.bark.type].color, scale);\n      this.branchesMesh.material.normalMap = loadTexture(textures.bark[this.params.bark.type].normal, scale);\n      this.branchesMesh.material.roughnessMap = loadTexture(textures.bark[this.params.bark.type].roughness, scale);\n    }\n  }\n\n  /**\n   * Generates the geometry for the leaves\n   */\n  createLeavesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.verts), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.leaves.indices), 1),\n    );\n    g.computeVertexNormals();\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'leaves',\n      color: this.params.leaves.tint,\n      side: THREE.DoubleSide,\n      alphaTest: this.params.leaves.alphaTest,\n    });\n\n    this.leavesMesh.geometry.dispose();\n    this.leavesMesh.geometry = g;\n    this.leavesMesh.material.dispose();\n    this.leavesMesh.material = mat;\n    this.leavesMesh.material.map = loadTexture(\n      textures.leaves[this.params.leaves.type],\n      new THREE.Vector2(1, 1),\n      THREE.SRGBColorSpace);\n\n    this.leavesMesh.castShadow = true;\n    this.leavesMesh.receiveShadow = true;\n  }\n}\n"],"names":["RNG","seed","__publicField","max","min","result","Branch","origin","THREE","orientation","length","radius","level","sectionCount","segmentCount","BarkType","Billboard","LeafType","TreeType","TreeParams","textureCache","textureLoader","loadTexture","path","scale","colorSpace","url","_documentCurrentScript","texture","Tree","params","branch","indexOffset","sectionOrientation","sectionOrigin","sectionLength","sections","i","sectionRadius","first","j","angle","vertex","normal","uv","gnarliness","qSection","qTwist","qForce","lastSection","count","radialOffset","childBranchStart","sectionIndex","sectionA","sectionB","alpha","childBranchOrigin","childBranchRadius","qA","qB","parentOrientation","radialAngle","q1","q2","q3","childBranchOrientation","childBranchLength","leafStart","leafOrigin","leafOrientation","leafSize","W","L","createLeaf","rotation","v","n","v1","v2","v3","v4","N","g","mat","textures.bark","textures.leaves"],"mappings":"ywBAAe,MAAMA,CAAI,CAKvB,YAAYC,EAAM,CAJlBC,EAAA,WAAM,WACNA,EAAA,WAAM,WACNA,EAAA,YAAO,YAGL,KAAK,IAAO,UAAYD,EAAQ,KAAK,KACrC,KAAK,IAAO,UAAYA,EAAQ,KAAK,IACtC,CAKD,OAAOE,EAAM,EAAGC,EAAM,EAAG,CACvB,KAAK,IAAO,OAAS,KAAK,IAAM,QAAU,KAAK,KAAO,IAAO,KAAK,KAClE,KAAK,IAAO,MAAS,KAAK,IAAM,QAAU,KAAK,KAAO,IAAO,KAAK,KAClE,IAAIC,GAAW,KAAK,KAAO,KAAO,KAAK,IAAM,SAAY,EACzD,OAAAA,GAAU,YAEFF,EAAMC,GAAOC,EAASD,CAC/B,CACH,CCnBO,MAAME,CAAO,CAQlB,YACEC,EAAS,IAAIC,EAAM,QACnBC,EAAc,IAAID,EAAM,MACxBE,EAAS,EACTC,EAAS,EACTC,EAAQ,EACRC,EAAe,EACfC,EAAe,EACf,CACA,KAAK,OAASP,EAAO,QACrB,KAAK,YAAcE,EAAY,QAC/B,KAAK,OAASC,EACd,KAAK,OAASC,EACd,KAAK,MAAQC,EACb,KAAK,aAAeC,EACpB,KAAK,aAAeC,CACrB,CACH,CC3BY,MAACC,EAAW,CACtB,MAAO,QACP,IAAK,MACL,KAAM,OACN,OAAQ,QACV,EAEaC,EAAY,CACvB,OAAQ,SACR,OAAQ,QACV,EAEaC,EAAW,CACtB,IAAK,MACL,MAAO,QACP,MAAO,QACP,UAAW,YACX,IAAK,KACP,EAEaC,EAAW,CACtB,UAAW,YACX,UAAW,WACb,ECrBaC,EAAa,CACxB,KAAM,EACN,KAAMD,EAAS,UAGf,KAAM,CAEJ,KAAMH,EAAS,IAGf,KAAM,SAGN,YAAa,GAGb,SAAU,GAGV,aAAc,CAAE,EAAG,EAAG,EAAG,CAAG,CAC7B,EAGD,OAAQ,CAEN,OAAQ,EAGR,MAAO,CACL,EAAG,GACH,EAAG,GACH,EAAG,EACJ,EAGD,SAAU,CACR,EAAG,EACH,EAAG,EACH,EAAG,CACJ,EAGD,MAAO,CACL,UAAW,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAG,EAC/B,SAAU,GACX,EAGD,WAAY,CACV,EAAG,IACH,EAAG,GACH,EAAG,GACH,EAAG,GACJ,EAGD,OAAQ,CACN,EAAG,GACH,EAAG,GACH,EAAG,GACH,EAAG,CACJ,EAGD,OAAQ,CACN,EAAG,IACH,EAAG,GACH,EAAG,GACH,EAAG,EACJ,EAGD,SAAU,CACR,EAAG,GACH,EAAG,GACH,EAAG,EACH,EAAG,CACJ,EAGD,SAAU,CACR,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,CACJ,EAGD,MAAO,CACL,EAAG,GACH,EAAG,GACH,EAAG,EACJ,EAGD,MAAO,CACL,EAAG,GACH,EAAG,GACH,EAAG,GACH,EAAG,EACJ,EAGD,MAAO,CACL,EAAG,EACH,EAAG,EACH,EAAG,EACH,EAAG,CACJ,CACF,EAGD,OAAQ,CAEN,KAAME,EAAS,IAGf,UAAWD,EAAU,OAGrB,MAAO,GAGP,MAAO,EAGP,MAAO,EAGP,KAAM,IAGN,aAAc,GAGd,KAAM,SAGN,UAAW,EACZ,CACH,msCCvIMI,EAAe,CAAA,EAEfC,EAAgB,IAAIb,EAAM,cAC1Bc,EAAc,CAACC,EAAMC,EAAQ,CAAE,EAAG,EAAG,EAAG,CAAC,EAAIC,EAAa,OAAS,CACvE,GAAI,CAACL,EAAaG,CAAI,EAAG,CACvB,MAAMG,EAAM,IAAI,IAAIH,EAAqB,OAAA,SAAA,KAAA,OAAA,SAAA,IAAA,QAAA,KAAA,EAAA,cAAA,UAAA,EAAA,KAAA,OAAA,SAAA,IAAA,SAAA,KAAAI,GAAAA,EAAA,KAAA,IAAA,IAAA,6BAAA,SAAA,OAAA,EAAA,IAAA,EAAE,KAC3CP,EAAaG,CAAI,EAAIF,EAAc,KAAKK,CAAG,CAC5C,CAKD,MAAME,EAAUR,EAAaG,CAAI,EACjC,OAAAK,EAAQ,MAAQpB,EAAM,uBACtBoB,EAAQ,MAAQpB,EAAM,uBACtBoB,EAAQ,OAAO,EAAIJ,EAAM,EACzBI,EAAQ,OAAO,EAAI,EAAIJ,EAAM,EAEzBC,IACFG,EAAQ,WAAaH,EACrBG,EAAQ,iBAAmB,IAGtBA,CACT,EAEO,MAAMC,UAAarB,EAAM,KAAM,CAmBpC,YAAYsB,EAASX,EAAY,CAC/B,QAhBFjB,EAAA,YAKAA,EAAA,eAKAA,EAAA,mBAAc,CAAA,GAOZ,KAAK,OAAS4B,EACd,KAAK,aAAe,IAAItB,EAAM,KAC9B,KAAK,WAAa,IAAIA,EAAM,KAC5B,KAAK,IAAI,KAAK,YAAY,EAC1B,KAAK,IAAI,KAAK,UAAU,CACzB,CAKD,UAAW,CA+BT,IA7BA,KAAK,SAAW,CACd,MAAO,CAAE,EACT,QAAS,CAAE,EACX,QAAS,CAAE,EACX,IAAK,CAAE,CACb,EAEI,KAAK,OAAS,CACZ,MAAO,CAAE,EACT,QAAS,CAAE,EACX,QAAS,CAAE,EACX,IAAK,CAAE,CACb,EAEI,KAAK,IAAM,IAAIR,EAAI,KAAK,OAAO,IAAI,EAGnC,KAAK,YAAY,KACf,IAAIM,EACF,IAAIE,EAAM,QACV,IAAIA,EAAM,MACV,KAAK,OAAO,OAAO,OAAO,CAAC,EAC3B,KAAK,OAAO,OAAO,OAAO,CAAC,EAC3B,EACA,KAAK,OAAO,OAAO,SAAS,CAAC,EAC7B,KAAK,OAAO,OAAO,SAAS,CAAC,CAC9B,CACP,EAEW,KAAK,YAAY,OAAS,GAAG,CAClC,MAAMuB,EAAS,KAAK,YAAY,MAAK,EACrC,KAAK,eAAeA,CAAM,CAC3B,CAED,KAAK,uBAAsB,EAC3B,KAAK,qBAAoB,CAC1B,CAOD,eAAeA,EAAQ,CAErB,MAAMC,EAAc,KAAK,SAAS,MAAM,OAAS,EAEjD,IAAIC,EAAqBF,EAAO,YAAY,MAAK,EAC7CG,EAAgBH,EAAO,OAAO,MAAK,EACnCI,EACFJ,EAAO,OACPA,EAAO,cACN,KAAK,OAAO,OAAS,YAAc,KAAK,OAAO,OAAO,OAAS,EAAI,GAIlEK,EAAW,CAAA,EAEf,QAASC,EAAI,EAAGA,GAAKN,EAAO,aAAcM,IAAK,CAC7C,IAAIC,EAAgBP,EAAO,OAIzBM,IAAMN,EAAO,cACbA,EAAO,QAAU,KAAK,OAAO,OAAO,OAEpCO,EAAgB,KACP,KAAK,OAAO,OAASpB,EAAS,UACvCoB,GACE,EAAI,KAAK,OAAO,OAAO,MAAMP,EAAO,KAAK,GAAKM,EAAIN,EAAO,cAClD,KAAK,OAAO,OAASb,EAAS,YAEvCoB,GAAiB,EAAKD,EAAIN,EAAO,cAInC,IAAIQ,EACJ,QAASC,EAAI,EAAGA,EAAIT,EAAO,aAAcS,IAAK,CAC5C,IAAIC,EAAS,EAAM,KAAK,GAAKD,EAAKT,EAAO,aAGzC,MAAMW,EAAS,IAAIlC,EAAM,QAAQ,KAAK,IAAIiC,CAAK,EAAG,EAAG,KAAK,IAAIA,CAAK,CAAC,EACjE,eAAeH,CAAa,EAC5B,WAAWL,CAAkB,EAC7B,IAAIC,CAAa,EAEdS,EAAS,IAAInC,EAAM,QAAQ,KAAK,IAAIiC,CAAK,EAAG,EAAG,KAAK,IAAIA,CAAK,CAAC,EACjE,WAAWR,CAAkB,EAC7B,YAEGW,EAAK,IAAIpC,EAAM,QACnBgC,EAAIT,EAAO,aACVM,EAAI,IAAM,EAAK,EAAI,CAC9B,EAEQ,KAAK,SAAS,MAAM,KAAK,GAAG,OAAO,OAAOK,CAAM,CAAC,EACjD,KAAK,SAAS,QAAQ,KAAK,GAAG,OAAO,OAAOC,CAAM,CAAC,EACnD,KAAK,SAAS,IAAI,KAAK,GAAG,OAAO,OAAOC,CAAE,CAAC,EAEvCJ,IAAM,IACRD,EAAQ,CAAE,OAAAG,EAAQ,OAAAC,EAAQ,GAAAC,CAAE,EAE/B,CAGD,KAAK,SAAS,MAAM,KAAK,GAAG,OAAO,OAAOL,EAAM,MAAM,CAAC,EACvD,KAAK,SAAS,QAAQ,KAAK,GAAG,OAAO,OAAOA,EAAM,MAAM,CAAC,EACzD,KAAK,SAAS,IAAI,KAAK,EAAGA,EAAM,GAAG,CAAC,EAGpCH,EAAS,KAAK,CACZ,OAAQF,EAAc,MAAO,EAC7B,YAAaD,EAAmB,MAAO,EACvC,OAAQK,CAChB,CAAO,EAEDJ,EAAc,IACZ,IAAI1B,EAAM,QAAQ,EAAG2B,EAAe,CAAC,EAAE,WAAWF,CAAkB,CAC5E,EAIM,MAAMY,EACJ,KAAK,IAAI,EAAG,EAAI,KAAK,KAAKP,CAAa,CAAC,EACxC,KAAK,OAAO,OAAO,WAAWP,EAAO,KAAK,EAE5CE,EAAmB,GAAK,KAAK,IAAI,OAAOY,EAAY,CAACA,CAAU,EAC/DZ,EAAmB,GAAK,KAAK,IAAI,OAAOY,EAAY,CAACA,CAAU,EAG/D,MAAMC,EAAW,IAAItC,EAAM,WAAU,EAAG,aAAayB,CAAkB,EAEjEc,EAAS,IAAIvC,EAAM,WAAY,EAAC,iBACpC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzB,KAAK,OAAO,OAAO,MAAMuB,EAAO,KAAK,CAC7C,EAEYiB,EAAS,IAAIxC,EAAM,WAAY,EAAC,mBACpC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzB,IAAIA,EAAM,QAAO,EAAG,KAAK,KAAK,OAAO,OAAO,MAAM,SAAS,CACnE,EAEMsC,EAAS,SAASC,CAAM,EACxBD,EAAS,cACPE,EACA,KAAK,OAAO,OAAO,MAAM,SAAWV,CAC5C,EAEML,EAAmB,kBAAkBa,CAAQ,CAC9C,CAMD,GAJA,KAAK,sBAAsBd,EAAaD,CAAM,EAI1C,KAAK,OAAO,OAAS,YAAa,CACpC,MAAMkB,EAAcb,EAASA,EAAS,OAAS,CAAC,EAE5CL,EAAO,MAAQ,KAAK,OAAO,OAAO,OACpC,KAAK,YAAY,KACf,IAAIzB,EACF2C,EAAY,OACZA,EAAY,YACZ,KAAK,OAAO,OAAO,OAAOlB,EAAO,MAAQ,CAAC,EAC1CkB,EAAY,OACZlB,EAAO,MAAQ,EAGfA,EAAO,aACPA,EAAO,YACR,CACX,EAEQ,KAAK,aAAakB,EAAY,OAAQA,EAAY,WAAW,CAEhE,CAGGlB,EAAO,QAAU,KAAK,OAAO,OAAO,OACtC,KAAK,eAAeK,CAAQ,EACnBL,EAAO,MAAQ,KAAK,OAAO,OAAO,QAC3C,KAAK,sBACH,KAAK,OAAO,OAAO,SAASA,EAAO,KAAK,EACxCA,EAAO,MAAQ,EACfK,CAAQ,CAEb,CAaD,sBAAsBc,EAAOtC,EAAOwB,EAAU,CAC5C,MAAMe,EAAe,KAAK,IAAI,OAAM,EAEpC,QAASd,EAAI,EAAGA,EAAIa,EAAOb,IAAK,CAG9B,IAAIe,EAAmB,KAAK,IAAI,OAAO,EAAK,KAAK,OAAO,OAAO,MAAMxC,CAAK,CAAC,EAI3E,MAAMyC,EAAe,KAAK,MAAMD,GAAoBhB,EAAS,OAAS,EAAE,EACxE,IAAIkB,EAAUC,EACdD,EAAWlB,EAASiB,CAAY,EAC5BA,IAAiBjB,EAAS,OAAS,EACrCmB,EAAWD,EAEXC,EAAWnB,EAASiB,EAAe,CAAC,EAItC,MAAMG,GACHJ,EAAmBC,GAAgBjB,EAAS,OAAS,KACrD,GAAKA,EAAS,OAAS,IAGpBqB,EAAoB,IAAIjD,EAAM,QAAS,EAAC,YAC5C8C,EAAS,OACTC,EAAS,OACTC,CACR,EAGYE,EACJ,KAAK,OAAO,OAAO,OAAO9C,CAAK,IAC7B,EAAI4C,GAASF,EAAS,OAASE,EAAQD,EAAS,QAG9CI,EAAK,IAAInD,EAAM,WAAY,EAAC,aAAa8C,EAAS,WAAW,EAC7DM,EAAK,IAAIpD,EAAM,WAAY,EAAC,aAAa+C,EAAS,WAAW,EAC7DM,EAAoB,IAAIrD,EAAM,MAAO,EAAC,kBAC1CoD,EAAG,MAAMD,EAAIH,CAAK,CAC1B,EAGYM,EAAc,EAAM,KAAK,IAAMX,EAAed,EAAIa,GAClDa,EAAK,IAAIvD,EAAM,WAAY,EAAC,iBAChC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzB,KAAK,OAAO,OAAO,MAAMI,CAAK,GAAK,IAAM,KAAK,GACtD,EACYoD,EAAK,IAAIxD,EAAM,WAAY,EAAC,iBAChC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzBsD,CACR,EACYG,EAAK,IAAIzD,EAAM,WAAU,EAAG,aAAaqD,CAAiB,EAE1DK,EAAyB,IAAI1D,EAAM,MAAO,EAAC,kBAC/CyD,EAAG,SAASD,EAAG,SAASD,CAAE,CAAC,CACnC,EAEM,IAAII,EACF,KAAK,OAAO,OAAO,OAAOvD,CAAK,GAC9B,KAAK,OAAO,OAASM,EAAS,UAC3B,EAAMkC,EACN,GAEN,KAAK,YAAY,KACf,IAAI9C,EACFmD,EACAS,EACAC,EACAT,EACA9C,EACA,KAAK,OAAO,OAAO,SAASA,CAAK,EACjC,KAAK,OAAO,OAAO,SAASA,CAAK,CAClC,CACT,CACK,CACF,CAWD,eAAewB,EAAU,CACvB,MAAMe,EAAe,KAAK,IAAI,OAAM,EAEpC,QAASd,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAO,MAAOA,IAAK,CAGjD,IAAI+B,EAAY,KAAK,IAAI,OAAO,EAAK,KAAK,OAAO,OAAO,KAAK,EAI7D,MAAMf,EAAe,KAAK,MAAMe,GAAahC,EAAS,OAAS,EAAE,EACjE,IAAIkB,EAAUC,EACdD,EAAWlB,EAASiB,CAAY,EAC5BA,IAAiBjB,EAAS,OAAS,EACrCmB,EAAWD,EAEXC,EAAWnB,EAASiB,EAAe,CAAC,EAItC,MAAMG,GACHY,EAAYf,GAAgBjB,EAAS,OAAS,KAC9C,GAAKA,EAAS,OAAS,IAGpBiC,EAAa,IAAI7D,EAAM,QAAS,EAAC,YACrC8C,EAAS,OACTC,EAAS,OACTC,CACR,EAGYG,EAAK,IAAInD,EAAM,WAAY,EAAC,aAAa8C,EAAS,WAAW,EAC7DM,EAAK,IAAIpD,EAAM,WAAY,EAAC,aAAa+C,EAAS,WAAW,EAC7DM,EAAoB,IAAIrD,EAAM,MAAO,EAAC,kBAC1CoD,EAAG,MAAMD,EAAIH,CAAK,CAC1B,EAGYM,EAAc,EAAM,KAAK,IAAMX,EAAed,EAAI,KAAK,OAAO,OAAO,OACrE0B,EAAK,IAAIvD,EAAM,WAAY,EAAC,iBAChC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzB,KAAK,OAAO,OAAO,OAAS,IAAM,KAAK,GAC/C,EACYwD,EAAK,IAAIxD,EAAM,WAAY,EAAC,iBAChC,IAAIA,EAAM,QAAQ,EAAG,EAAG,CAAC,EACzBsD,CACR,EACYG,EAAK,IAAIzD,EAAM,WAAU,EAAG,aAAaqD,CAAiB,EAE1DS,EAAkB,IAAI9D,EAAM,MAAO,EAAC,kBACxCyD,EAAG,SAASD,EAAG,SAASD,CAAE,CAAC,CACnC,EAEM,KAAK,aAAaM,EAAYC,CAAe,CAC9C,CACF,CAOD,aAAa/D,EAAQE,EAAa,CAChC,IAAI4B,EAAI,KAAK,OAAO,MAAM,OAAS,EAG/BkC,EACF,KAAK,OAAO,OAAO,MAClB,EACC,KAAK,IAAI,OACP,KAAK,OAAO,OAAO,aACnB,CAAC,KAAK,OAAO,OAAO,YAC9B,GAEI,MAAMC,EAAID,EACJE,EAAI,IAAMF,EAEVG,EAAcC,GAAa,CAE/B,MAAMC,EAAI,CACR,IAAIpE,EAAM,QAAQ,CAACgE,EAAI,EAAGC,EAAG,CAAC,EAC9B,IAAIjE,EAAM,QAAQ,CAACgE,EAAI,EAAG,EAAG,CAAC,EAC9B,IAAIhE,EAAM,QAAQgE,EAAI,EAAG,EAAG,CAAC,EAC7B,IAAIhE,EAAM,QAAQgE,EAAI,EAAGC,EAAG,CAAC,CACrC,EAAQ,IAAKG,GACLA,EACG,WAAW,IAAIpE,EAAM,MAAM,EAAGmE,EAAU,CAAC,CAAC,EAC1C,WAAWlE,CAAW,EACtB,IAAIF,CAAM,CACrB,EAEM,KAAK,OAAO,MAAM,KAChBqE,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,EACLA,EAAE,CAAC,EAAE,CACb,EAEM,MAAMC,EAAI,IAAIrE,EAAM,QAAQ,EAAG,EAAG,CAAC,EAAE,WAAWC,CAAW,EAC3D,KAAK,OAAO,QAAQ,KAClBoE,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,EACFA,EAAE,CACV,EACM,KAAK,OAAO,IAAI,KAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EAC3C,KAAK,OAAO,QAAQ,KAAKxC,EAAGA,EAAI,EAAGA,EAAI,EAAGA,EAAGA,EAAI,EAAGA,EAAI,CAAC,EACzDA,GAAK,CACX,EAEIqC,EAAW,CAAC,EACR,KAAK,OAAO,OAAO,YAAc1D,EAAU,QAC7C0D,EAAW,KAAK,GAAK,CAAC,CAEzB,CAMD,sBAAsB1C,EAAaD,EAAQ,CAEzC,IAAI+C,EAAIC,EAAIC,EAAIC,EAChB,MAAMC,EAAInD,EAAO,aAAe,EAChC,QAASM,EAAI,EAAGA,EAAIN,EAAO,aAAcM,IAEvC,QAASG,EAAI,EAAGA,EAAIT,EAAO,aAAcS,IACvCsC,EAAK9C,EAAcK,EAAI6C,EAAI1C,EAE3BuC,EAAK/C,EAAcK,EAAI6C,GAAK1C,EAAI,GAChCwC,EAAKF,EAAKI,EACVD,EAAKF,EAAKG,EACV,KAAK,SAAS,QAAQ,KAAKJ,EAAIE,EAAID,EAAIA,EAAIC,EAAIC,CAAE,CAGtD,CAKD,wBAAyB,CACvB,MAAME,EAAI,IAAI3E,EAAM,eACpB2E,EAAE,aACA,WACA,IAAI3E,EAAM,gBAAgB,IAAI,aAAa,KAAK,SAAS,KAAK,EAAG,CAAC,CACxE,EACI2E,EAAE,aACA,SACA,IAAI3E,EAAM,gBAAgB,IAAI,aAAa,KAAK,SAAS,OAAO,EAAG,CAAC,CAC1E,EACI2E,EAAE,aACA,KACA,IAAI3E,EAAM,gBAAgB,IAAI,aAAa,KAAK,SAAS,GAAG,EAAG,CAAC,CACtE,EACI2E,EAAE,SACA,IAAI3E,EAAM,gBAAgB,IAAI,YAAY,KAAK,SAAS,OAAO,EAAG,CAAC,CACzE,EACI2E,EAAE,sBAAqB,EAEvB,MAAMC,EAAM,IAAI5E,EAAM,qBAAqB,CACzC,KAAM,WACN,YAAa,KAAK,OAAO,KAAK,YAC9B,MAAO,KAAK,OAAO,KAAK,IAC9B,CAAK,EASD,GAPA,KAAK,aAAa,SAAS,UAC3B,KAAK,aAAa,SAAW2E,EAC7B,KAAK,aAAa,SAAS,UAC3B,KAAK,aAAa,SAAWC,EAC7B,KAAK,aAAa,WAAa,GAC/B,KAAK,aAAa,cAAgB,GAE9B,KAAK,OAAO,KAAK,SAAU,CAC7B,MAAM5D,EAAQ,KAAK,OAAO,KAAK,aAC/B,KAAK,aAAa,SAAS,MAAQF,EAAY+D,EAAc,KAAK,OAAO,KAAK,IAAI,EAAE,GAAI7D,CAAK,EAC7F,KAAK,aAAa,SAAS,IAAMF,EAAY+D,EAAc,KAAK,OAAO,KAAK,IAAI,EAAE,MAAO7D,CAAK,EAC9F,KAAK,aAAa,SAAS,UAAYF,EAAY+D,EAAc,KAAK,OAAO,KAAK,IAAI,EAAE,OAAQ7D,CAAK,EACrG,KAAK,aAAa,SAAS,aAAeF,EAAY+D,EAAc,KAAK,OAAO,KAAK,IAAI,EAAE,UAAW7D,CAAK,CAC5G,CACF,CAKD,sBAAuB,CACrB,MAAM2D,EAAI,IAAI3E,EAAM,eACpB2E,EAAE,aACA,WACA,IAAI3E,EAAM,gBAAgB,IAAI,aAAa,KAAK,OAAO,KAAK,EAAG,CAAC,CACtE,EACI2E,EAAE,aACA,KACA,IAAI3E,EAAM,gBAAgB,IAAI,aAAa,KAAK,OAAO,GAAG,EAAG,CAAC,CACpE,EACI2E,EAAE,SACA,IAAI3E,EAAM,gBAAgB,IAAI,YAAY,KAAK,OAAO,OAAO,EAAG,CAAC,CACvE,EACI2E,EAAE,qBAAoB,EACtBA,EAAE,sBAAqB,EAEvB,MAAMC,EAAM,IAAI5E,EAAM,qBAAqB,CACzC,KAAM,SACN,MAAO,KAAK,OAAO,OAAO,KAC1B,KAAMA,EAAM,WACZ,UAAW,KAAK,OAAO,OAAO,SACpC,CAAK,EAED,KAAK,WAAW,SAAS,UACzB,KAAK,WAAW,SAAW2E,EAC3B,KAAK,WAAW,SAAS,UACzB,KAAK,WAAW,SAAWC,EAC3B,KAAK,WAAW,SAAS,IAAM9D,EAC7BgE,EAAgB,KAAK,OAAO,OAAO,IAAI,EACvC,IAAI9E,EAAM,QAAQ,EAAG,CAAC,EACtBA,EAAM,cAAc,EAEtB,KAAK,WAAW,WAAa,GAC7B,KAAK,WAAW,cAAgB,EACjC,CACH"}