{"version":3,"file":"@dgreenheck-tree-js.umd.js","sources":["../src/rng.js","../src/branch.js","../src/enums.js","../src/options.js","../src/presets/index.js","../src/tree.js"],"sourcesContent":["export default class RNG {\n  m_w = 123456789;\n  m_z = 987654321;\n  mask = 0xffffffff;\n\n  constructor(seed) {\n    this.m_w = (123456789 + seed) & this.mask;\n    this.m_z = (987654321 - seed) & this.mask;\n  }\n\n  /**\n   * Returns a random number between min and max\n   */\n  random(max = 1, min = 0) {\n    this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & this.mask;\n    this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & this.mask;\n    let result = ((this.m_z << 16) + (this.m_w & 65535)) >>> 0;\n    result /= 4294967296;\n\n    return (max - min) * result + min;\n  }\n}\n","import * as THREE from 'three';\n\nexport class Branch {\n  /**\n   * Generates a new branch\n   * @param {THREE.Vector3} origin The starting point of the branch\n   * @param {THREE.Euler} orientation The starting orientation of the branch\n   * @param {number} length The length of the branch\n   * @param {number} radius The radius of the branch at its starting point\n   */\n  constructor(\n    origin = new THREE.Vector3(),\n    orientation = new THREE.Euler(),\n    length = 0,\n    radius = 0,\n    level = 0,\n    sectionCount = 0,\n    segmentCount = 0,\n  ) {\n    this.origin = origin.clone();\n    this.orientation = orientation.clone();\n    this.length = length;\n    this.radius = radius;\n    this.level = level;\n    this.sectionCount = sectionCount;\n    this.segmentCount = segmentCount;\n  }\n}\n","export const BarkType = {\n  Birch: 'birch',\n  Oak: 'oak',\n  Pine: 'pine',\n  Willow: 'willow'\n};\n\nexport const Billboard = {\n  Single: 'single',\n  Double: 'double',\n};\n\nexport const LeafType = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Pine: 'pine',\n  Oak: 'oak',\n};\n\nexport const TreePreset = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Pine: 'pine',\n  Oak: 'oak'\n};\n\nexport const TreeType = {\n  Deciduous: 'deciduous',\n  Evergreen: 'evergreen',\n};","import { BarkType, Billboard, LeafType, TreeType } from './enums';\n\nexport default class TreeOptions {\n  constructor() {\n    this.seed = 0;\n    this.type = TreeType.Deciduous;\n\n    // Bark parameters\n    this.bark = {\n      // The bark texture\n      type: BarkType.Oak,\n\n      // Tint of the tree trunk\n      tint: 0xffffff,\n\n      // Use face normals for shading instead of vertex normals\n      flatShading: false,\n\n      // Apply texture to bark\n      textured: true,\n\n      // Scale for the texture\n      textureScale: { x: 1, y: 1 },\n    };\n\n    // Branch parameters\n    this.branch = {\n      // Number of branch recursion levels. 0 = trunk only\n      levels: 3,\n\n      // Angle of the child branches relative to the parent branch (degrees)\n      angle: {\n        1: 70,\n        2: 60,\n        3: 60,\n      },\n\n      // Number of children per branch level\n      children: {\n        0: 7,\n        1: 7,\n        2: 5,\n      },\n\n      // External force encouraging tree growth in a particular direction\n      force: {\n        direction: { x: 0, y: 1, z: 0 },\n        strength: 0.01,\n      },\n\n      // Amount of curling/twisting at each branch level\n      gnarliness: {\n        0: 0.15,\n        1: 0.2,\n        2: 0.3,\n        3: 0.02,\n      },\n\n      // Length of each branch level\n      length: {\n        0: 20,\n        1: 20,\n        2: 10,\n        3: 1,\n      },\n\n      // Radius of each branch level\n      radius: {\n        0: 1.5,\n        1: 0.7,\n        2: 0.7,\n        3: 0.7,\n      },\n\n      // Number of sections per branch level\n      sections: {\n        0: 12,\n        1: 10,\n        2: 8,\n        3: 6,\n      },\n\n      // Number of radial segments per branch level\n      segments: {\n        0: 8,\n        1: 6,\n        2: 4,\n        3: 3,\n      },\n\n      // Defines where child branches start forming on the parent branch\n      start: {\n        1: 0.4,\n        2: 0.3,\n        3: 0.3,\n      },\n\n      // Taper at each branch level\n      taper: {\n        0: 0.7,\n        1: 0.7,\n        2: 0.7,\n        3: 0.7,\n      },\n\n      // Amount of twist at each branch level\n      twist: {\n        0: 0,\n        1: 0,\n        2: 0,\n        3: 0,\n      },\n    };\n\n    // Leaf parameters\n    this.leaves = {\n      // Leaf texture to use\n      type: LeafType.Oak,\n\n      // Whether to use single or double/perpendicular billboards\n      billboard: Billboard.Double,\n\n      // Angle of leaves relative to parent branch (degrees)\n      angle: 10,\n\n      // Number of leaves\n      count: 1,\n\n      // Where leaves start to grow on the length of the branch (0 to 1)\n      start: 0,\n\n      // Size of the leaves\n      size: 2.5,\n\n      // Variance in leaf size between each instance\n      sizeVariance: 0.7,\n\n      // Tint color for the leaves\n      tint: 0xffffff,\n\n      // Controls transparency of leaf texture\n      alphaTest: 0.5,\n    };\n  }\n}","import ash from './ash.json';\nimport aspen from './aspen.json';\nimport oak from './oak.json';\nimport pine from './pine.json';\nimport { TreePreset } from '../enums';\nimport TreeOptions from '../options';\n\nexport function loadPreset(name) {\n  switch (name) {\n    case TreePreset.Ash:\n      return ash;\n    case TreePreset.Aspen:\n      return aspen;\n    case TreePreset.Oak:\n      return oak;\n    case TreePreset.Pine:\n      return pine;\n    default:\n      return new TreeOptions();\n  }\n}","import * as THREE from 'three';\nimport * as path from 'path';\nimport RNG from './rng';\nimport { Branch } from './branch';\nimport { Billboard, TreePreset, TreeType } from './enums';\nimport TreeOptions from './options';\nimport { loadPreset } from './presets/index.js';\n\nconst textureCache = {};\n\nconst textureLoader = new THREE.TextureLoader();\n\n/**\n * \n * @param {string} path Path relative to the `textures` directory\n * @param {*} scale \n * @param {*} colorSpace \n * @returns \n */\nconst loadTexture = (path, scale = { x: 1, y: 1 }, colorSpace = null) => {\n  if (!textureCache[path]) {\n    const url = new URL('../src/textures/' + path, import.meta.url).href;\n    textureCache[path] = textureLoader.load(url);\n  }\n\n  /**\n   * @type {THREE.Texture}\n   */\n  const texture = textureCache[path];\n  texture.wrapS = THREE.MirroredRepeatWrapping;\n  texture.wrapT = THREE.MirroredRepeatWrapping;\n  texture.repeat.x = scale.x;\n  texture.repeat.y = 1 / scale.y;\n\n  if (colorSpace) {\n    texture.colorSpace = colorSpace;\n    texture.premultiplyAlpha = true;\n  }\n\n  return texture;\n};\n\nexport class Tree extends THREE.Group {\n  /**\n   * @type {RNG}\n   */\n  rng;\n\n  /**\n   * @type {TreeOptions}\n   */\n  options;\n\n  /**\n   * @type {Branch[]}\n   */\n  branchQueue = [];\n\n  /**\n   * @param {TreeOptions} params\n   */\n  constructor(options = new TreeOptions()) {\n    super();\n    this.branchesMesh = new THREE.Mesh();\n    this.leavesMesh = new THREE.Mesh();\n    this.add(this.branchesMesh);\n    this.add(this.leavesMesh);\n    this.options = options;\n  }\n\n  /**\n   * Loads a preset tree from JSON \n   * @param {string} preset \n   */\n  loadPreset(name) {\n    this.options = loadPreset(name);\n    this.generate();\n  }\n\n  /**\n   * Generate a new tree\n   */\n  generate() {\n    // Clean up old geometry\n    this.branches = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.leaves = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.rng = new RNG(this.options.seed);\n\n    // Create the trunk of the tree first\n    this.branchQueue.push(\n      new Branch(\n        new THREE.Vector3(),\n        new THREE.Euler(),\n        this.options.branch.length[0],\n        this.options.branch.radius[0],\n        0,\n        this.options.branch.sections[0],\n        this.options.branch.segments[0],\n      ),\n    );\n\n    while (this.branchQueue.length > 0) {\n      const branch = this.branchQueue.shift();\n      this.generateBranch(branch);\n    }\n\n    this.createBranchesGeometry();\n    this.createLeavesGeometry();\n  }\n\n  /**\n   * Generates a new branch\n   * @param {Branch} branch\n   * @returns\n   */\n  generateBranch(branch) {\n    // Used later for geometry index generation\n    const indexOffset = this.branches.verts.length / 3;\n\n    let sectionOrientation = branch.orientation.clone();\n    let sectionOrigin = branch.origin.clone();\n    let sectionLength =\n      branch.length /\n      branch.sectionCount /\n      (this.options.type === 'Deciduous' ? this.options.branch.levels - 1 : 1);\n\n    // This information is used for generating child branches after the branch\n    // geometry has been constructed\n    let sections = [];\n\n    for (let i = 0; i <= branch.sectionCount; i++) {\n      let sectionRadius = branch.radius;\n\n      // If final section of final level, set radius to effecively zero\n      if (\n        i === branch.sectionCount &&\n        branch.level === this.options.branch.levels\n      ) {\n        sectionRadius = 0.001;\n      } else if (this.options.type === TreeType.Deciduous) {\n        sectionRadius *=\n          1 - this.options.branch.taper[branch.level] * (i / branch.sectionCount);\n      } else if (this.options.type === TreeType.Evergreen) {\n        // Evergreens do not have a terminal branch so they have a taper of 1\n        sectionRadius *= 1 - (i / branch.sectionCount);\n      }\n\n      // Create the segments that make up this section.\n      let first;\n      for (let j = 0; j < branch.segmentCount; j++) {\n        let angle = (2.0 * Math.PI * j) / branch.segmentCount;\n\n        // Create the segment vertex\n        const vertex = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .multiplyScalar(sectionRadius)\n          .applyEuler(sectionOrientation)\n          .add(sectionOrigin);\n\n        const normal = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .applyEuler(sectionOrientation)\n          .normalize();\n\n        const uv = new THREE.Vector2(\n          j / branch.segmentCount,\n          (i % 2 === 0) ? 0 : 1,\n        );\n\n        this.branches.verts.push(...Object.values(vertex));\n        this.branches.normals.push(...Object.values(normal));\n        this.branches.uvs.push(...Object.values(uv));\n\n        if (j === 0) {\n          first = { vertex, normal, uv };\n        }\n      }\n\n      // Duplicate the first vertex so there is continuity in the UV mapping\n      this.branches.verts.push(...Object.values(first.vertex));\n      this.branches.normals.push(...Object.values(first.normal));\n      this.branches.uvs.push(1, first.uv.y);\n\n      // Use this information later on when generating child branches\n      sections.push({\n        origin: sectionOrigin.clone(),\n        orientation: sectionOrientation.clone(),\n        radius: sectionRadius,\n      });\n\n      sectionOrigin.add(\n        new THREE.Vector3(0, sectionLength, 0).applyEuler(sectionOrientation),\n      );\n\n      // Perturb the orientation of the next section randomly. The higher the\n      // gnarliness, the larger potential perturbation\n      const gnarliness =\n        Math.max(1, 1 / Math.sqrt(sectionRadius)) *\n        this.options.branch.gnarliness[branch.level];\n\n      sectionOrientation.x += this.rng.random(gnarliness, -gnarliness);\n      sectionOrientation.z += this.rng.random(gnarliness, -gnarliness);\n\n      // Apply growth force to the branch\n      const qSection = new THREE.Quaternion().setFromEuler(sectionOrientation);\n\n      const qTwist = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        this.options.branch.twist[branch.level],\n      );\n\n      const qForce = new THREE.Quaternion().setFromUnitVectors(\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3().copy(this.options.branch.force.direction),\n      );\n\n      qSection.multiply(qTwist);\n      qSection.rotateTowards(\n        qForce,\n        this.options.branch.force.strength / sectionRadius,\n      );\n\n      sectionOrientation.setFromQuaternion(qSection);\n    }\n\n    this.generateBranchIndices(indexOffset, branch);\n\n    // Deciduous trees have a terminal branch that grows out of the\n    // end of the parent branch\n    if (this.options.type === 'deciduous') {\n      const lastSection = sections[sections.length - 1];\n\n      if (branch.level < this.options.branch.levels) {\n        this.branchQueue.push(\n          new Branch(\n            lastSection.origin,\n            lastSection.orientation,\n            this.options.branch.length[branch.level + 1],\n            lastSection.radius,\n            branch.level + 1,\n            // Section count and segment count must be same as parent branch\n            // since the child branch is growing from the end of the parent branch\n            branch.sectionCount,\n            branch.segmentCount,\n          ),\n        );\n      } else {\n        this.generateLeaf(lastSection.origin, lastSection.orientation);\n      }\n    }\n\n    // If we are on the last branch level, generate leaves\n    if (branch.level === this.options.branch.levels) {\n      this.generateLeaves(sections);\n    } else if (branch.level < this.options.branch.levels) {\n      this.generateChildBranches(\n        this.options.branch.children[branch.level],\n        branch.level + 1,\n        sections);\n    }\n  }\n\n  /**\n   * Generate branches from a parent branch\n   * @param {number} count The number of child branches to generate\n   * @param {number} level The level of the child branches\n   * @param {{\n   *  origin: THREE.Vector3,\n   *  orientation: THREE.Euler,\n   *  radius: number\n   * }[]} sections The parent branch's sections\n   * @returns\n   */\n  generateChildBranches(count, level, sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < count; i++) {\n      // Determine how far along the length of the parent branch the child\n      // branch should originate from (0 to 1)\n      let childBranchStart = this.rng.random(1.0, this.options.branch.start[level]);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(childBranchStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (childBranchStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const childBranchOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearly interpolate radius\n      const childBranchRadius =\n        this.options.branch.radius[level] *\n        ((1 - alpha) * sectionA.radius + alpha * sectionB.radius);\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.options.branch.angle[level] / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const childBranchOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      let childBranchLength =\n        this.options.branch.length[level] *\n        (this.options.type === TreeType.Evergreen\n          ? 1.0 - childBranchStart\n          : 1.0);\n\n      this.branchQueue.push(\n        new Branch(\n          childBranchOrigin,\n          childBranchOrientation,\n          childBranchLength,\n          childBranchRadius,\n          level,\n          this.options.branch.sections[level],\n          this.options.branch.segments[level],\n        ),\n      );\n    }\n  }\n\n  /**\n   * Logic for spawning child branches from a parent branch's section\n   * @param {{\n  *  origin: THREE.Vector3,\n  *  orientation: THREE.Euler,\n  *  radius: number\n  * }[]} sections The parent branch's sections\n  * @returns\n  */\n  generateLeaves(sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < this.options.leaves.count; i++) {\n      // Determine how far along the length of the parent\n      // branch the leaf should originate from (0 to 1)\n      let leafStart = this.rng.random(1.0, this.options.leaves.start);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(leafStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (leafStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const leafOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / this.options.leaves.count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.options.leaves.angle / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const leafOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      this.generateLeaf(leafOrigin, leafOrientation);\n    }\n  }\n\n  /**\n * Generates a leaves\n * @param {THREE.Vector3} origin The starting point of the branch\n * @param {THREE.Euler} orientation The starting orientation of the branch\n */\n  generateLeaf(origin, orientation) {\n    let i = this.leaves.verts.length / 3;\n\n    // Width and length of the leaf quad\n    let leafSize =\n      this.options.leaves.size *\n      (1 +\n        this.rng.random(\n          this.options.leaves.sizeVariance,\n          -this.options.leaves.sizeVariance,\n        ));\n\n    const W = leafSize;\n    const L = 1.5 * leafSize;\n\n    const createLeaf = (rotation) => {\n      // Create quad vertices\n      const v = [\n        new THREE.Vector3(-W / 2, L, 0),\n        new THREE.Vector3(-W / 2, 0, 0),\n        new THREE.Vector3(W / 2, 0, 0),\n        new THREE.Vector3(W / 2, L, 0),\n      ].map((v) =>\n        v\n          .applyEuler(new THREE.Euler(0, rotation, 0))\n          .applyEuler(orientation)\n          .add(origin),\n      );\n\n      this.leaves.verts.push(\n        v[0].x,\n        v[0].y,\n        v[0].z,\n        v[1].x,\n        v[1].y,\n        v[1].z,\n        v[2].x,\n        v[2].y,\n        v[2].z,\n        v[3].x,\n        v[3].y,\n        v[3].z,\n      );\n\n      const n = new THREE.Vector3(0, 0, 1).applyEuler(orientation);\n      this.leaves.normals.push(\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n      );\n      this.leaves.uvs.push(0, 1, 0, 0, 1, 0, 1, 1);\n      this.leaves.indices.push(i, i + 1, i + 2, i, i + 2, i + 3);\n      i += 4;\n    };\n\n    createLeaf(0);\n    if (this.options.leaves.billboard === Billboard.Double) {\n      createLeaf(Math.PI / 2);\n    }\n  }\n\n  /**\n   * Generates the indices for branch geometry\n   * @param {Branch} branch\n   */\n  generateBranchIndices(indexOffset, branch) {\n    // Build geometry each section of the branch (cylinder without end caps)\n    let v1, v2, v3, v4;\n    const N = branch.segmentCount + 1;\n    for (let i = 0; i < branch.sectionCount; i++) {\n      // Build the quad for each segment of the section\n      for (let j = 0; j < branch.segmentCount; j++) {\n        v1 = indexOffset + i * N + j;\n        // The last segment wraps around back to the starting segment, so omit j + 1 term\n        v2 = indexOffset + i * N + (j + 1);\n        v3 = v1 + N;\n        v4 = v2 + N;\n        this.branches.indices.push(v1, v3, v2, v2, v3, v4);\n      }\n    }\n  }\n\n  /**\n   * Generates the geometry for the branches\n   */\n  createBranchesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.branches.verts), 3),\n    );\n    g.setAttribute(\n      'normal',\n      new THREE.BufferAttribute(new Float32Array(this.branches.normals), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.branches.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.branches.indices), 1),\n    );\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'branches',\n      flatShading: this.options.bark.flatShading,\n      color: this.options.bark.tint,\n    });\n\n    this.branchesMesh.geometry.dispose();\n    this.branchesMesh.geometry = g;\n    this.branchesMesh.material.dispose();\n    this.branchesMesh.material = mat;\n    this.branchesMesh.castShadow = true;\n    this.branchesMesh.receiveShadow = true;\n\n    if (this.options.bark.textured) {\n      const scale = this.options.bark.textureScale;\n      this.branchesMesh.material.aoMap = loadTexture(`bark/${this.options.bark.type}_ao_1k.jpg`, scale);\n      this.branchesMesh.material.map = loadTexture(`bark/${this.options.bark.type}_color_1k.jpg`, scale);\n      this.branchesMesh.material.normalMap = loadTexture(`bark/${this.options.bark.type}_normal_1k.jpg`, scale);\n      this.branchesMesh.material.roughnessMap = loadTexture(`bark/${this.options.bark.type}_roughness_1k.jpg`, scale);\n    }\n  }\n\n  /**\n   * Generates the geometry for the leaves\n   */\n  createLeavesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.verts), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.leaves.indices), 1),\n    );\n    g.computeVertexNormals();\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'leaves',\n      color: this.options.leaves.tint,\n      side: THREE.DoubleSide,\n      alphaTest: this.options.leaves.alphaTest,\n    });\n\n    this.leavesMesh.geometry.dispose();\n    this.leavesMesh.geometry = g;\n    this.leavesMesh.material.dispose();\n    this.leavesMesh.material = mat;\n    this.leavesMesh.material.map = loadTexture(\n      `leaves/${this.options.leaves.type}_color.png`,\n      new THREE.Vector2(1, 1),\n      THREE.SRGBColorSpace);\n\n    this.leavesMesh.castShadow = true;\n    this.leavesMesh.receiveShadow = true;\n  }\n}\n"],"names":["RNG","seed","__publicField","max","min","result","Branch","origin","THREE","orientation","length","radius","level","sectionCount","segmentCount","BarkType","Billboard","LeafType","TreePreset","TreeType","TreeOptions","loadPreset","name","ash","aspen","oak","pine","textureCache","textureLoader","loadTexture","path","scale","colorSpace","url","_documentCurrentScript","texture","Tree","options","branch","indexOffset","sectionOrientation","sectionOrigin","sectionLength","sections","i","sectionRadius","first","j","angle","vertex","normal","uv","gnarliness","qSection","qTwist","qForce","lastSection","count","radialOffset","childBranchStart","sectionIndex","sectionA","sectionB","alpha","childBranchOrigin","childBranchRadius","qA","qB","parentOrientation","radialAngle","q1","q2","q3","childBranchOrientation","childBranchLength","leafStart","leafOrigin","leafOrientation","leafSize","W","L","createLeaf","rotation","v","n","v1","v2","v3","v4","N","g","mat"],"mappings":"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"}