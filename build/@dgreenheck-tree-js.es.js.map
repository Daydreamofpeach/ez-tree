{"version":3,"file":"@dgreenheck-tree-js.es.js","sources":["../src/rng.js","../src/branch.js","../src/enums.js","../src/options.js","../src/presets/index.js","../src/tree.js"],"sourcesContent":["export default class RNG {\n  m_w = 123456789;\n  m_z = 987654321;\n  mask = 0xffffffff;\n\n  constructor(seed) {\n    this.m_w = (123456789 + seed) & this.mask;\n    this.m_z = (987654321 - seed) & this.mask;\n  }\n\n  /**\n   * Returns a random number between min and max\n   */\n  random(max = 1, min = 0) {\n    this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & this.mask;\n    this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & this.mask;\n    let result = ((this.m_z << 16) + (this.m_w & 65535)) >>> 0;\n    result /= 4294967296;\n\n    return (max - min) * result + min;\n  }\n}\n","import * as THREE from 'three';\n\nexport class Branch {\n  /**\n   * Generates a new branch\n   * @param {THREE.Vector3} origin The starting point of the branch\n   * @param {THREE.Euler} orientation The starting orientation of the branch\n   * @param {number} length The length of the branch\n   * @param {number} radius The radius of the branch at its starting point\n   */\n  constructor(\n    origin = new THREE.Vector3(),\n    orientation = new THREE.Euler(),\n    length = 0,\n    radius = 0,\n    level = 0,\n    sectionCount = 0,\n    segmentCount = 0,\n  ) {\n    this.origin = origin.clone();\n    this.orientation = orientation.clone();\n    this.length = length;\n    this.radius = radius;\n    this.level = level;\n    this.sectionCount = sectionCount;\n    this.segmentCount = segmentCount;\n  }\n}\n","export const BarkType = {\n  Birch: 'birch',\n  Oak: 'oak',\n  Pine: 'pine',\n  Willow: 'willow'\n};\n\nexport const Billboard = {\n  Single: 'single',\n  Double: 'double',\n};\n\nexport const LeafType = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Pine: 'pine',\n  Oak: 'oak',\n};\n\nexport const TreePreset = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Pine: 'pine',\n  Oak: 'oak'\n};\n\nexport const TreeType = {\n  Deciduous: 'deciduous',\n  Evergreen: 'evergreen',\n};","import { BarkType, Billboard, LeafType, TreeType } from './enums';\n\nexport default class TreeOptions {\n  constructor() {\n    this.seed = 0;\n    this.type = TreeType.Deciduous;\n\n    // Bark parameters\n    this.bark = {\n      // The bark texture\n      type: BarkType.Oak,\n\n      // Tint of the tree trunk\n      tint: 0xffffff,\n\n      // Use face normals for shading instead of vertex normals\n      flatShading: false,\n\n      // Apply texture to bark\n      textured: true,\n\n      // Scale for the texture\n      textureScale: { x: 1, y: 1 },\n    };\n\n    // Branch parameters\n    this.branch = {\n      // Number of branch recursion levels. 0 = trunk only\n      levels: 3,\n\n      // Angle of the child branches relative to the parent branch (degrees)\n      angle: {\n        1: 70,\n        2: 60,\n        3: 60,\n      },\n\n      // Number of children per branch level\n      children: {\n        0: 7,\n        1: 7,\n        2: 5,\n      },\n\n      // External force encouraging tree growth in a particular direction\n      force: {\n        direction: { x: 0, y: 1, z: 0 },\n        strength: 0.01,\n      },\n\n      // Amount of curling/twisting at each branch level\n      gnarliness: {\n        0: 0.15,\n        1: 0.2,\n        2: 0.3,\n        3: 0.02,\n      },\n\n      // Length of each branch level\n      length: {\n        0: 20,\n        1: 20,\n        2: 10,\n        3: 1,\n      },\n\n      // Radius of each branch level\n      radius: {\n        0: 1.5,\n        1: 0.7,\n        2: 0.7,\n        3: 0.7,\n      },\n\n      // Number of sections per branch level\n      sections: {\n        0: 12,\n        1: 10,\n        2: 8,\n        3: 6,\n      },\n\n      // Number of radial segments per branch level\n      segments: {\n        0: 8,\n        1: 6,\n        2: 4,\n        3: 3,\n      },\n\n      // Defines where child branches start forming on the parent branch\n      start: {\n        1: 0.4,\n        2: 0.3,\n        3: 0.3,\n      },\n\n      // Taper at each branch level\n      taper: {\n        0: 0.7,\n        1: 0.7,\n        2: 0.7,\n        3: 0.7,\n      },\n\n      // Amount of twist at each branch level\n      twist: {\n        0: 0,\n        1: 0,\n        2: 0,\n        3: 0,\n      },\n    };\n\n    // Leaf parameters\n    this.leaves = {\n      // Leaf texture to use\n      type: LeafType.Oak,\n\n      // Whether to use single or double/perpendicular billboards\n      billboard: Billboard.Double,\n\n      // Angle of leaves relative to parent branch (degrees)\n      angle: 10,\n\n      // Number of leaves\n      count: 1,\n\n      // Where leaves start to grow on the length of the branch (0 to 1)\n      start: 0,\n\n      // Size of the leaves\n      size: 2.5,\n\n      // Variance in leaf size between each instance\n      sizeVariance: 0.7,\n\n      // Tint color for the leaves\n      tint: 0xffffff,\n\n      // Controls transparency of leaf texture\n      alphaTest: 0.5,\n    };\n  }\n}","import ash from './ash.json';\nimport aspen from './aspen.json';\nimport oak from './oak.json';\nimport pine from './pine.json';\nimport { TreePreset } from '../enums';\nimport TreeOptions from '../options';\n\nexport function loadPreset(name) {\n  switch (name) {\n    case TreePreset.Ash:\n      return ash;\n    case TreePreset.Aspen:\n      return aspen;\n    case TreePreset.Oak:\n      return oak;\n    case TreePreset.Pine:\n      return pine;\n    default:\n      return new TreeOptions();\n  }\n}","import * as THREE from 'three';\nimport RNG from './rng';\nimport { Branch } from './branch';\nimport { Billboard, TreePreset, TreeType } from './enums';\nimport TreeOptions from './options';\nimport { loadPreset } from './presets/index.js';\n\nconst textureCache = {};\n\nconst textureLoader = new THREE.TextureLoader();\n\n/**\n * \n * @param {string} path Path relative to the `textures` directory\n * @param {*} scale \n * @param {*} colorSpace \n * @returns \n */\nconst loadTexture = (path, scale = { x: 1, y: 1 }, colorSpace = null) => {\n  if (!textureCache[path]) {\n    const url = new URL('../src/textures/' + path, import.meta.url).href;\n    textureCache[path] = textureLoader.load(url);\n  }\n\n  /**\n   * @type {THREE.Texture}\n   */\n  const texture = textureCache[path];\n  texture.wrapS = THREE.MirroredRepeatWrapping;\n  texture.wrapT = THREE.MirroredRepeatWrapping;\n  texture.repeat.x = scale.x;\n  texture.repeat.y = 1 / scale.y;\n\n  if (colorSpace) {\n    texture.colorSpace = colorSpace;\n  }\n\n  return texture;\n};\n\nexport class Tree extends THREE.Group {\n  /**\n   * @type {RNG}\n   */\n  rng;\n\n  /**\n   * @type {TreeOptions}\n   */\n  options;\n\n  /**\n   * @type {Branch[]}\n   */\n  branchQueue = [];\n\n  /**\n   * @param {TreeOptions} params\n   */\n  constructor(options = new TreeOptions()) {\n    super();\n    this.branchesMesh = new THREE.Mesh();\n    this.leavesMesh = new THREE.Mesh();\n    this.add(this.branchesMesh);\n    this.add(this.leavesMesh);\n    this.options = options;\n  }\n\n  /**\n   * Loads a preset tree from JSON \n   * @param {string} preset \n   */\n  loadPreset(name) {\n    this.options = loadPreset(name);\n    this.generate();\n  }\n\n  /**\n   * Generate a new tree\n   */\n  generate() {\n    // Clean up old geometry\n    this.branches = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.leaves = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.rng = new RNG(this.options.seed);\n\n    // Create the trunk of the tree first\n    this.branchQueue.push(\n      new Branch(\n        new THREE.Vector3(),\n        new THREE.Euler(),\n        this.options.branch.length[0],\n        this.options.branch.radius[0],\n        0,\n        this.options.branch.sections[0],\n        this.options.branch.segments[0],\n      ),\n    );\n\n    while (this.branchQueue.length > 0) {\n      const branch = this.branchQueue.shift();\n      this.generateBranch(branch);\n    }\n\n    this.createBranchesGeometry();\n    this.createLeavesGeometry();\n  }\n\n  /**\n   * Generates a new branch\n   * @param {Branch} branch\n   * @returns\n   */\n  generateBranch(branch) {\n    // Used later for geometry index generation\n    const indexOffset = this.branches.verts.length / 3;\n\n    let sectionOrientation = branch.orientation.clone();\n    let sectionOrigin = branch.origin.clone();\n    let sectionLength =\n      branch.length /\n      branch.sectionCount /\n      (this.options.type === 'Deciduous' ? this.options.branch.levels - 1 : 1);\n\n    // This information is used for generating child branches after the branch\n    // geometry has been constructed\n    let sections = [];\n\n    for (let i = 0; i <= branch.sectionCount; i++) {\n      let sectionRadius = branch.radius;\n\n      // If final section of final level, set radius to effecively zero\n      if (\n        i === branch.sectionCount &&\n        branch.level === this.options.branch.levels\n      ) {\n        sectionRadius = 0.001;\n      } else if (this.options.type === TreeType.Deciduous) {\n        sectionRadius *=\n          1 - this.options.branch.taper[branch.level] * (i / branch.sectionCount);\n      } else if (this.options.type === TreeType.Evergreen) {\n        // Evergreens do not have a terminal branch so they have a taper of 1\n        sectionRadius *= 1 - (i / branch.sectionCount);\n      }\n\n      // Create the segments that make up this section.\n      let first;\n      for (let j = 0; j < branch.segmentCount; j++) {\n        let angle = (2.0 * Math.PI * j) / branch.segmentCount;\n\n        // Create the segment vertex\n        const vertex = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .multiplyScalar(sectionRadius)\n          .applyEuler(sectionOrientation)\n          .add(sectionOrigin);\n\n        const normal = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .applyEuler(sectionOrientation)\n          .normalize();\n\n        const uv = new THREE.Vector2(\n          j / branch.segmentCount,\n          (i % 2 === 0) ? 0 : 1,\n        );\n\n        this.branches.verts.push(...Object.values(vertex));\n        this.branches.normals.push(...Object.values(normal));\n        this.branches.uvs.push(...Object.values(uv));\n\n        if (j === 0) {\n          first = { vertex, normal, uv };\n        }\n      }\n\n      // Duplicate the first vertex so there is continuity in the UV mapping\n      this.branches.verts.push(...Object.values(first.vertex));\n      this.branches.normals.push(...Object.values(first.normal));\n      this.branches.uvs.push(1, first.uv.y);\n\n      // Use this information later on when generating child branches\n      sections.push({\n        origin: sectionOrigin.clone(),\n        orientation: sectionOrientation.clone(),\n        radius: sectionRadius,\n      });\n\n      sectionOrigin.add(\n        new THREE.Vector3(0, sectionLength, 0).applyEuler(sectionOrientation),\n      );\n\n      // Perturb the orientation of the next section randomly. The higher the\n      // gnarliness, the larger potential perturbation\n      const gnarliness =\n        Math.max(1, 1 / Math.sqrt(sectionRadius)) *\n        this.options.branch.gnarliness[branch.level];\n\n      sectionOrientation.x += this.rng.random(gnarliness, -gnarliness);\n      sectionOrientation.z += this.rng.random(gnarliness, -gnarliness);\n\n      // Apply growth force to the branch\n      const qSection = new THREE.Quaternion().setFromEuler(sectionOrientation);\n\n      const qTwist = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        this.options.branch.twist[branch.level],\n      );\n\n      const qForce = new THREE.Quaternion().setFromUnitVectors(\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3().copy(this.options.branch.force.direction),\n      );\n\n      qSection.multiply(qTwist);\n      qSection.rotateTowards(\n        qForce,\n        this.options.branch.force.strength / sectionRadius,\n      );\n\n      sectionOrientation.setFromQuaternion(qSection);\n    }\n\n    this.generateBranchIndices(indexOffset, branch);\n\n    // Deciduous trees have a terminal branch that grows out of the\n    // end of the parent branch\n    if (this.options.type === 'deciduous') {\n      const lastSection = sections[sections.length - 1];\n\n      if (branch.level < this.options.branch.levels) {\n        this.branchQueue.push(\n          new Branch(\n            lastSection.origin,\n            lastSection.orientation,\n            this.options.branch.length[branch.level + 1],\n            lastSection.radius,\n            branch.level + 1,\n            // Section count and segment count must be same as parent branch\n            // since the child branch is growing from the end of the parent branch\n            branch.sectionCount,\n            branch.segmentCount,\n          ),\n        );\n      } else {\n        this.generateLeaf(lastSection.origin, lastSection.orientation);\n      }\n    }\n\n    // If we are on the last branch level, generate leaves\n    if (branch.level === this.options.branch.levels) {\n      this.generateLeaves(sections);\n    } else if (branch.level < this.options.branch.levels) {\n      this.generateChildBranches(\n        this.options.branch.children[branch.level],\n        branch.level + 1,\n        sections);\n    }\n  }\n\n  /**\n   * Generate branches from a parent branch\n   * @param {number} count The number of child branches to generate\n   * @param {number} level The level of the child branches\n   * @param {{\n   *  origin: THREE.Vector3,\n   *  orientation: THREE.Euler,\n   *  radius: number\n   * }[]} sections The parent branch's sections\n   * @returns\n   */\n  generateChildBranches(count, level, sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < count; i++) {\n      // Determine how far along the length of the parent branch the child\n      // branch should originate from (0 to 1)\n      let childBranchStart = this.rng.random(1.0, this.options.branch.start[level]);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(childBranchStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (childBranchStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const childBranchOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearly interpolate radius\n      const childBranchRadius =\n        this.options.branch.radius[level] *\n        ((1 - alpha) * sectionA.radius + alpha * sectionB.radius);\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.options.branch.angle[level] / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const childBranchOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      let childBranchLength =\n        this.options.branch.length[level] *\n        (this.options.type === TreeType.Evergreen\n          ? 1.0 - childBranchStart\n          : 1.0);\n\n      this.branchQueue.push(\n        new Branch(\n          childBranchOrigin,\n          childBranchOrientation,\n          childBranchLength,\n          childBranchRadius,\n          level,\n          this.options.branch.sections[level],\n          this.options.branch.segments[level],\n        ),\n      );\n    }\n  }\n\n  /**\n   * Logic for spawning child branches from a parent branch's section\n   * @param {{\n  *  origin: THREE.Vector3,\n  *  orientation: THREE.Euler,\n  *  radius: number\n  * }[]} sections The parent branch's sections\n  * @returns\n  */\n  generateLeaves(sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < this.options.leaves.count; i++) {\n      // Determine how far along the length of the parent\n      // branch the leaf should originate from (0 to 1)\n      let leafStart = this.rng.random(1.0, this.options.leaves.start);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(leafStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (leafStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const leafOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / this.options.leaves.count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.options.leaves.angle / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const leafOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      this.generateLeaf(leafOrigin, leafOrientation);\n    }\n  }\n\n  /**\n * Generates a leaves\n * @param {THREE.Vector3} origin The starting point of the branch\n * @param {THREE.Euler} orientation The starting orientation of the branch\n */\n  generateLeaf(origin, orientation) {\n    let i = this.leaves.verts.length / 3;\n\n    // Width and length of the leaf quad\n    let leafSize =\n      this.options.leaves.size *\n      (1 +\n        this.rng.random(\n          this.options.leaves.sizeVariance,\n          -this.options.leaves.sizeVariance,\n        ));\n\n    const W = leafSize;\n    const L = 1.5 * leafSize;\n\n    const createLeaf = (rotation) => {\n      // Create quad vertices\n      const v = [\n        new THREE.Vector3(-W / 2, L, 0),\n        new THREE.Vector3(-W / 2, 0, 0),\n        new THREE.Vector3(W / 2, 0, 0),\n        new THREE.Vector3(W / 2, L, 0),\n      ].map((v) =>\n        v\n          .applyEuler(new THREE.Euler(0, rotation, 0))\n          .applyEuler(orientation)\n          .add(origin),\n      );\n\n      this.leaves.verts.push(\n        v[0].x,\n        v[0].y,\n        v[0].z,\n        v[1].x,\n        v[1].y,\n        v[1].z,\n        v[2].x,\n        v[2].y,\n        v[2].z,\n        v[3].x,\n        v[3].y,\n        v[3].z,\n      );\n\n      const n = new THREE.Vector3(0, 0, 1).applyEuler(orientation);\n      this.leaves.normals.push(\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n      );\n      this.leaves.uvs.push(0, 1, 0, 0, 1, 0, 1, 1);\n      this.leaves.indices.push(i, i + 1, i + 2, i, i + 2, i + 3);\n      i += 4;\n    };\n\n    createLeaf(0);\n    if (this.options.leaves.billboard === Billboard.Double) {\n      createLeaf(Math.PI / 2);\n    }\n  }\n\n  /**\n   * Generates the indices for branch geometry\n   * @param {Branch} branch\n   */\n  generateBranchIndices(indexOffset, branch) {\n    // Build geometry each section of the branch (cylinder without end caps)\n    let v1, v2, v3, v4;\n    const N = branch.segmentCount + 1;\n    for (let i = 0; i < branch.sectionCount; i++) {\n      // Build the quad for each segment of the section\n      for (let j = 0; j < branch.segmentCount; j++) {\n        v1 = indexOffset + i * N + j;\n        // The last segment wraps around back to the starting segment, so omit j + 1 term\n        v2 = indexOffset + i * N + (j + 1);\n        v3 = v1 + N;\n        v4 = v2 + N;\n        this.branches.indices.push(v1, v3, v2, v2, v3, v4);\n      }\n    }\n  }\n\n  /**\n   * Generates the geometry for the branches\n   */\n  createBranchesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.branches.verts), 3),\n    );\n    g.setAttribute(\n      'normal',\n      new THREE.BufferAttribute(new Float32Array(this.branches.normals), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.branches.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.branches.indices), 1),\n    );\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'branches',\n      flatShading: this.options.bark.flatShading,\n      color: this.options.bark.tint,\n    });\n\n    this.branchesMesh.geometry.dispose();\n    this.branchesMesh.geometry = g;\n    this.branchesMesh.material.dispose();\n    this.branchesMesh.material = mat;\n    this.branchesMesh.castShadow = true;\n    this.branchesMesh.receiveShadow = true;\n\n    if (this.options.bark.textured) {\n      const scale = this.options.bark.textureScale;\n      this.branchesMesh.material.aoMap = loadTexture(`bark/${this.options.bark.type}_ao_1k.jpg`, scale);\n      this.branchesMesh.material.map = loadTexture(`bark/${this.options.bark.type}_color_1k.jpg`, scale);\n      this.branchesMesh.material.normalMap = loadTexture(`bark/${this.options.bark.type}_normal_1k.jpg`, scale);\n      this.branchesMesh.material.roughnessMap = loadTexture(`bark/${this.options.bark.type}_roughness_1k.jpg`, scale);\n    }\n  }\n\n  /**\n   * Generates the geometry for the leaves\n   */\n  createLeavesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.verts), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.leaves.indices), 1),\n    );\n    g.computeVertexNormals();\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'leaves',\n      color: this.options.leaves.tint,\n      side: THREE.DoubleSide,\n      alphaTest: this.options.leaves.alphaTest,\n      premultipliedAlpha: true\n    });\n\n    this.leavesMesh.geometry.dispose();\n    this.leavesMesh.geometry = g;\n    this.leavesMesh.material.dispose();\n    this.leavesMesh.material = mat;\n    this.leavesMesh.material.map = loadTexture(\n      `leaves/${this.options.leaves.type}_color.png`,\n      new THREE.Vector2(1, 1),\n      THREE.SRGBColorSpace);\n\n    this.leavesMesh.castShadow = true;\n    this.leavesMesh.receiveShadow = true;\n  }\n}\n"],"names":["RNG","seed","__publicField","max","min","result","Branch","origin","THREE","orientation","length","radius","level","sectionCount","segmentCount","BarkType","Billboard","LeafType","TreePreset","TreeType","TreeOptions","loadPreset","name","ash","aspen","oak","pine","textureCache","textureLoader","loadTexture","path","scale","colorSpace","url","texture","Tree","options","branch","indexOffset","sectionOrientation","sectionOrigin","sectionLength","sections","sectionRadius","first","j","angle","vertex","normal","uv","gnarliness","qSection","qTwist","qForce","lastSection","count","radialOffset","i","childBranchStart","sectionIndex","sectionA","sectionB","alpha","childBranchOrigin","childBranchRadius","qA","qB","parentOrientation","radialAngle","q1","q2","q3","childBranchOrientation","childBranchLength","leafStart","leafOrigin","leafOrientation","leafSize","W","L","createLeaf","rotation","v","n","v1","v2","v3","v4","N","g","mat"],"mappings":"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"}