{"version":3,"file":"@dgreenheck-tree-js.es.js","sources":["../src/rng.js","../src/branch.js","../src/enums.js","../src/treeParams.js","../src/tree.js"],"sourcesContent":["export default class RNG {\n  m_w = 123456789;\n  m_z = 987654321;\n  mask = 0xffffffff;\n\n  constructor(seed) {\n    this.m_w = (123456789 + seed) & this.mask;\n    this.m_z = (987654321 - seed) & this.mask;\n  }\n\n  /**\n   * Returns a random number between min and max\n   */\n  random(max = 1, min = 0) {\n    this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & this.mask;\n    this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & this.mask;\n    let result = ((this.m_z << 16) + (this.m_w & 65535)) >>> 0;\n    result /= 4294967296;\n\n    return (max - min) * result + min;\n  }\n}\n","import * as THREE from 'three';\n\nexport class Branch {\n  /**\n   * Generates a new branch\n   * @param {THREE.Vector3} origin The starting point of the branch\n   * @param {THREE.Euler} orientation The starting orientation of the branch\n   * @param {number} length The length of the branch\n   * @param {number} radius The radius of the branch at its starting point\n   */\n  constructor(\n    origin = new THREE.Vector3(),\n    orientation = new THREE.Euler(),\n    length = 0,\n    radius = 0,\n    level = 0,\n    sectionCount = 0,\n    segmentCount = 0,\n  ) {\n    this.origin = origin.clone();\n    this.orientation = orientation.clone();\n    this.length = length;\n    this.radius = radius;\n    this.level = level;\n    this.sectionCount = sectionCount;\n    this.segmentCount = segmentCount;\n  }\n}\n","export const BarkType = {\n  Birch: 'birch',\n  Oak: 'oak',\n  Pine: 'pine',\n  Willow: 'willow'\n};\n\nexport const Billboard = {\n  Single: 'single',\n  Double: 'double',\n};\n\nexport const LeafType = {\n  Ash: 'ash',\n  Aspen: 'aspen',\n  Beech: 'beech',\n  Evergreen: 'evergreen',\n  Oak: 'oak',\n};\n\nexport const TreeType = {\n  Deciduous: 'deciduous',\n  Evergreen: 'evergreen',\n};","import { BarkType, Billboard, LeafType, TreeType } from './enums'\n\nexport const TreeParams = {\n  seed: 0,\n  type: TreeType.Deciduous,\n\n  // Bark parameters\n  bark: {\n    // The bark texture\n    type: BarkType.Oak,\n\n    // Tint of the tree trunk\n    tint: 0xffffff,\n\n    // Use face normals for shading instead of vertex normals\n    flatShading: false,\n\n    // Apply texture to bark\n    textured: true,\n\n    // Scale for the texture\n    textureScale: { x: 1, y: 1 }\n  },\n\n  // Branch parameters\n  branch: {\n    // Number of branch recursion levels. 0 = trunk only\n    levels: 3,\n\n    // Angle of the child branches relative to the parent branch (degrees)\n    angle: {\n      1: 70,\n      2: 60,\n      3: 60\n    },\n\n    // Number of children per branch level\n    children: {\n      0: 7,\n      1: 7,\n      2: 5\n    },\n\n    // External force encouraging tree growth in a particular direction\n    force: {\n      direction: { x: 0, y: 1, z: 0 },\n      strength: 0.01,\n    },\n\n    // Amount of curling/twisting  at each branch level\n    gnarliness: {\n      0: 0.15,\n      1: 0.2,\n      2: 0.3,\n      3: 0.02,\n    },\n\n    // Length of each branch level\n    length: {\n      0: 20,\n      1: 20,\n      2: 10,\n      3: 1\n    },\n\n    // Radius of each branch level\n    radius: {\n      0: 1.5,\n      1: 0.7,\n      2: 0.7,\n      3: 0.7\n    },\n\n    // Number of sections per branch level\n    sections: {\n      0: 12,\n      1: 10,\n      2: 8,\n      3: 6,\n    },\n\n    // Number of radial segments per branch level\n    segments: {\n      0: 8,\n      1: 6,\n      2: 4,\n      3: 3,\n    },\n\n    // Defines where child branches start forming on the parent branch\n    start: {\n      1: 0.4,\n      2: 0.3,\n      3: 0.3\n    },\n\n    // Taper at each branch level\n    taper: {\n      0: 0.7,\n      1: 0.7,\n      2: 0.7,\n      3: 0.7,\n    },\n\n    // Amount of twist at each branch level\n    twist: {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 0,\n    },\n  },\n\n  // Leaf parameters\n  leaves: {\n    // Leaf texture to use\n    type: LeafType.Oak,\n\n    // Whether to use single or double/perpendicular billboards\n    billboard: Billboard.Double,\n\n    // Angle of leaves relative to parent branch (degrees)\n    angle: 10,\n\n    // Number of leaves\n    count: 1,\n\n    // Where leaves start to grow on the length of the branch (0 to 1)\n    start: 0,\n\n    // Size of the leaves\n    size: 2.5,\n\n    // Variance in leaf size between each instance\n    sizeVariance: 0.7,\n\n    // Tint color for the leaves\n    tint: 0xffffff,\n\n    // Controls transparency of leaf texture\n    alphaTest: 0.5,\n  },\n};","import * as THREE from 'three';\nimport RNG from './rng';\nimport { Branch } from './branch';\nimport { Billboard, TreeType } from './enums';\nimport { TreeParams } from './treeParams';\nimport * as textures from './textures/index.json';\n\nconst textureCache = {};\n\nconst textureLoader = new THREE.TextureLoader();\nconst loadTexture = (path, scale = { x: 1, y: 1 }, colorSpace = null) => {\n  if (!textureCache[path]) {\n    const url = new URL(path, import.meta.url).href;\n    textureCache[path] = textureLoader.load(url);\n  }\n\n  /**\n   * @type {THREE.Texture}\n   */\n  const texture = textureCache[path];\n  texture.wrapS = THREE.MirroredRepeatWrapping;\n  texture.wrapT = THREE.MirroredRepeatWrapping;\n  texture.repeat.x = scale.x;\n  texture.repeat.y = 1 / scale.y;\n\n  if (colorSpace) {\n    texture.colorSpace = colorSpace;\n    texture.premultiplyAlpha = true;\n  }\n\n  return texture;\n};\n\nexport class Tree extends THREE.Group {\n  /**\n   * @type {RNG}\n   */\n  rng;\n\n  /**\n   * @type {TreeParams}\n   */\n  params;\n\n  /**\n   * @type {Branch[]}\n   */\n  branchQueue = [];\n\n  /**\n   * @param {TreeParams} params\n   */\n  constructor(params = TreeParams) {\n    super();\n    this.params = params;\n    this.branchesMesh = new THREE.Mesh();\n    this.leavesMesh = new THREE.Mesh();\n    this.add(this.branchesMesh);\n    this.add(this.leavesMesh);\n  }\n\n  /**\n   * Generate a new tree\n   */\n  generate() {\n    // Clean up old geometry\n    this.branches = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.leaves = {\n      verts: [],\n      normals: [],\n      indices: [],\n      uvs: [],\n    };\n\n    this.rng = new RNG(this.params.seed);\n\n    // Create the trunk of the tree first\n    this.branchQueue.push(\n      new Branch(\n        new THREE.Vector3(),\n        new THREE.Euler(),\n        this.params.branch.length[0],\n        this.params.branch.radius[0],\n        0,\n        this.params.branch.sections[0],\n        this.params.branch.segments[0],\n      ),\n    );\n\n    while (this.branchQueue.length > 0) {\n      const branch = this.branchQueue.shift();\n      this.generateBranch(branch);\n    }\n\n    this.createBranchesGeometry();\n    this.createLeavesGeometry();\n  }\n\n  /**\n   * Generates a new branch\n   * @param {Branch} branch\n   * @returns\n   */\n  generateBranch(branch) {\n    // Used later for geometry index generation\n    const indexOffset = this.branches.verts.length / 3;\n\n    let sectionOrientation = branch.orientation.clone();\n    let sectionOrigin = branch.origin.clone();\n    let sectionLength =\n      branch.length /\n      branch.sectionCount /\n      (this.params.type === 'Deciduous' ? this.params.branch.levels - 1 : 1);\n\n    // This information is used for generating child branches after the branch\n    // geometry has been constructed\n    let sections = [];\n\n    for (let i = 0; i <= branch.sectionCount; i++) {\n      let sectionRadius = branch.radius;\n\n      // If final section of final level, set radius to effecively zero\n      if (\n        i === branch.sectionCount &&\n        branch.level === this.params.branch.levels\n      ) {\n        sectionRadius = 0.001;\n      } else if (this.params.type === TreeType.Deciduous) {\n        sectionRadius *=\n          1 - this.params.branch.taper[branch.level] * (i / branch.sectionCount);\n      } else if (this.params.type === TreeType.Evergreen) {\n        // Evergreens do not have a terminal branch so they have a taper of 1\n        sectionRadius *= 1 - (i / branch.sectionCount);\n      }\n\n      // Create the segments that make up this section.\n      let first;\n      for (let j = 0; j < branch.segmentCount; j++) {\n        let angle = (2.0 * Math.PI * j) / branch.segmentCount;\n\n        // Create the segment vertex\n        const vertex = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .multiplyScalar(sectionRadius)\n          .applyEuler(sectionOrientation)\n          .add(sectionOrigin);\n\n        const normal = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))\n          .applyEuler(sectionOrientation)\n          .normalize();\n\n        const uv = new THREE.Vector2(\n          j / branch.segmentCount,\n          (i % 2 === 0) ? 0 : 1,\n        );\n\n        this.branches.verts.push(...Object.values(vertex));\n        this.branches.normals.push(...Object.values(normal));\n        this.branches.uvs.push(...Object.values(uv));\n\n        if (j === 0) {\n          first = { vertex, normal, uv };\n        }\n      }\n\n      // Duplicate the first vertex so there is continuity in the UV mapping\n      this.branches.verts.push(...Object.values(first.vertex));\n      this.branches.normals.push(...Object.values(first.normal));\n      this.branches.uvs.push(1, first.uv.y);\n\n      // Use this information later on when generating child branches\n      sections.push({\n        origin: sectionOrigin.clone(),\n        orientation: sectionOrientation.clone(),\n        radius: sectionRadius,\n      });\n\n      sectionOrigin.add(\n        new THREE.Vector3(0, sectionLength, 0).applyEuler(sectionOrientation),\n      );\n\n      // Perturb the orientation of the next section randomly. The higher the\n      // gnarliness, the larger potential perturbation\n      const gnarliness =\n        Math.max(1, 1 / Math.sqrt(sectionRadius)) *\n        this.params.branch.gnarliness[branch.level];\n\n      sectionOrientation.x += this.rng.random(gnarliness, -gnarliness);\n      sectionOrientation.z += this.rng.random(gnarliness, -gnarliness);\n\n      // Apply growth force to the branch\n      const qSection = new THREE.Quaternion().setFromEuler(sectionOrientation);\n\n      const qTwist = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        this.params.branch.twist[branch.level],\n      );\n\n      const qForce = new THREE.Quaternion().setFromUnitVectors(\n        new THREE.Vector3(0, 1, 0),\n        new THREE.Vector3().copy(this.params.branch.force.direction),\n      );\n\n      qSection.multiply(qTwist);\n      qSection.rotateTowards(\n        qForce,\n        this.params.branch.force.strength / sectionRadius,\n      );\n\n      sectionOrientation.setFromQuaternion(qSection);\n    }\n\n    this.generateBranchIndices(indexOffset, branch);\n\n    // Deciduous trees have a terminal branch that grows out of the\n    // end of the parent branch\n    if (this.params.type === 'deciduous') {\n      const lastSection = sections[sections.length - 1];\n\n      if (branch.level < this.params.branch.levels) {\n        this.branchQueue.push(\n          new Branch(\n            lastSection.origin,\n            lastSection.orientation,\n            this.params.branch.length[branch.level + 1],\n            lastSection.radius,\n            branch.level + 1,\n            // Section count and segment count must be same as parent branch\n            // since the child branch is growing from the end of the parent branch\n            branch.sectionCount,\n            branch.segmentCount,\n          ),\n        );\n      } else {\n        this.generateLeaf(lastSection.origin, lastSection.orientation);\n      }\n    }\n\n    // If we are on the last branch level, generate leaves\n    if (branch.level === this.params.branch.levels) {\n      this.generateLeaves(sections);\n    } else if (branch.level < this.params.branch.levels) {\n      this.generateChildBranches(\n        this.params.branch.children[branch.level],\n        branch.level + 1,\n        sections);\n    }\n  }\n\n  /**\n   * Generate branches from a parent branch\n   * @param {number} count The number of child branches to generate\n   * @param {number} level The level of the child branches\n   * @param {{\n   *  origin: THREE.Vector3,\n   *  orientation: THREE.Euler,\n   *  radius: number\n   * }[]} sections The parent branch's sections\n   * @returns\n   */\n  generateChildBranches(count, level, sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < count; i++) {\n      // Determine how far along the length of the parent branch the child\n      // branch should originate from (0 to 1)\n      let childBranchStart = this.rng.random(1.0, this.params.branch.start[level]);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(childBranchStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (childBranchStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const childBranchOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearly interpolate radius\n      const childBranchRadius =\n        this.params.branch.radius[level] *\n        ((1 - alpha) * sectionA.radius + alpha * sectionB.radius);\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.params.branch.angle[level] / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const childBranchOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      let childBranchLength =\n        this.params.branch.length[level] *\n        (this.params.type === TreeType.Evergreen\n          ? 1.0 - childBranchStart\n          : 1.0);\n\n      this.branchQueue.push(\n        new Branch(\n          childBranchOrigin,\n          childBranchOrientation,\n          childBranchLength,\n          childBranchRadius,\n          level,\n          this.params.branch.sections[level],\n          this.params.branch.segments[level],\n        ),\n      );\n    }\n  }\n\n  /**\n   * Logic for spawning child branches from a parent branch's section\n   * @param {{\n  *  origin: THREE.Vector3,\n  *  orientation: THREE.Euler,\n  *  radius: number\n  * }[]} sections The parent branch's sections\n  * @returns\n  */\n  generateLeaves(sections) {\n    const radialOffset = this.rng.random();\n\n    for (let i = 0; i < this.params.leaves.count; i++) {\n      // Determine how far along the length of the parent\n      // branch the leaf should originate from (0 to 1)\n      let leafStart = this.rng.random(1.0, this.params.leaves.start);\n\n      // Find which sections are on either side of the child branch origin point\n      // so we can determine the origin, orientation and radius of the branch\n      const sectionIndex = Math.floor(leafStart * (sections.length - 1));\n      let sectionA, sectionB;\n      sectionA = sections[sectionIndex];\n      if (sectionIndex === sections.length - 1) {\n        sectionB = sectionA;\n      } else {\n        sectionB = sections[sectionIndex + 1];\n      }\n\n      // Find normalized distance from section A to section B (0 to 1)\n      const alpha =\n        (leafStart - sectionIndex / (sections.length - 1)) /\n        (1 / (sections.length - 1));\n\n      // Linearly interpolate origin from section A to section B\n      const leafOrigin = new THREE.Vector3().lerpVectors(\n        sectionA.origin,\n        sectionB.origin,\n        alpha,\n      );\n\n      // Linearlly interpolate the orientation\n      const qA = new THREE.Quaternion().setFromEuler(sectionA.orientation);\n      const qB = new THREE.Quaternion().setFromEuler(sectionB.orientation);\n      const parentOrientation = new THREE.Euler().setFromQuaternion(\n        qB.slerp(qA, alpha),\n      );\n\n      // Calculate the angle offset from the parent branch and the radial angle\n      const radialAngle = 2.0 * Math.PI * (radialOffset + i / this.params.leaves.count);\n      const q1 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(1, 0, 0),\n        this.params.leaves.angle / (180 / Math.PI),\n      );\n      const q2 = new THREE.Quaternion().setFromAxisAngle(\n        new THREE.Vector3(0, 1, 0),\n        radialAngle,\n      );\n      const q3 = new THREE.Quaternion().setFromEuler(parentOrientation);\n\n      const leafOrientation = new THREE.Euler().setFromQuaternion(\n        q3.multiply(q2.multiply(q1)),\n      );\n\n      this.generateLeaf(leafOrigin, leafOrientation);\n    }\n  }\n\n  /**\n * Generates a leaves\n * @param {THREE.Vector3} origin The starting point of the branch\n * @param {THREE.Euler} orientation The starting orientation of the branch\n */\n  generateLeaf(origin, orientation) {\n    let i = this.leaves.verts.length / 3;\n\n    // Width and length of the leaf quad\n    let leafSize =\n      this.params.leaves.size *\n      (1 +\n        this.rng.random(\n          this.params.leaves.sizeVariance,\n          -this.params.leaves.sizeVariance,\n        ));\n\n    const W = leafSize;\n    const L = 1.5 * leafSize;\n\n    const createLeaf = (rotation) => {\n      // Create quad vertices\n      const v = [\n        new THREE.Vector3(-W / 2, L, 0),\n        new THREE.Vector3(-W / 2, 0, 0),\n        new THREE.Vector3(W / 2, 0, 0),\n        new THREE.Vector3(W / 2, L, 0),\n      ].map((v) =>\n        v\n          .applyEuler(new THREE.Euler(0, rotation, 0))\n          .applyEuler(orientation)\n          .add(origin),\n      );\n\n      this.leaves.verts.push(\n        v[0].x,\n        v[0].y,\n        v[0].z,\n        v[1].x,\n        v[1].y,\n        v[1].z,\n        v[2].x,\n        v[2].y,\n        v[2].z,\n        v[3].x,\n        v[3].y,\n        v[3].z,\n      );\n\n      const n = new THREE.Vector3(0, 0, 1).applyEuler(orientation);\n      this.leaves.normals.push(\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n        n.x,\n        n.y,\n        n.z,\n      );\n      this.leaves.uvs.push(0, 1, 0, 0, 1, 0, 1, 1);\n      this.leaves.indices.push(i, i + 1, i + 2, i, i + 2, i + 3);\n      i += 4;\n    };\n\n    createLeaf(0);\n    if (this.params.leaves.billboard === Billboard.Double) {\n      createLeaf(Math.PI / 2);\n    }\n  }\n\n  /**\n   * Generates the indices for branch geometry\n   * @param {Branch} branch\n   */\n  generateBranchIndices(indexOffset, branch) {\n    // Build geometry each section of the branch (cylinder without end caps)\n    let v1, v2, v3, v4;\n    const N = branch.segmentCount + 1;\n    for (let i = 0; i < branch.sectionCount; i++) {\n      // Build the quad for each segment of the section\n      for (let j = 0; j < branch.segmentCount; j++) {\n        v1 = indexOffset + i * N + j;\n        // The last segment wraps around back to the starting segment, so omit j + 1 term\n        v2 = indexOffset + i * N + (j + 1);\n        v3 = v1 + N;\n        v4 = v2 + N;\n        this.branches.indices.push(v1, v3, v2, v2, v3, v4);\n      }\n    }\n  }\n\n  /**\n   * Generates the geometry for the branches\n   */\n  createBranchesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.branches.verts), 3),\n    );\n    g.setAttribute(\n      'normal',\n      new THREE.BufferAttribute(new Float32Array(this.branches.normals), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.branches.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.branches.indices), 1),\n    );\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'branches',\n      flatShading: this.params.bark.flatShading,\n      color: this.params.bark.tint,\n    });\n\n    this.branchesMesh.geometry.dispose();\n    this.branchesMesh.geometry = g;\n    this.branchesMesh.material.dispose();\n    this.branchesMesh.material = mat;\n    this.branchesMesh.castShadow = true;\n    this.branchesMesh.receiveShadow = true;\n\n    if (this.params.bark.textured) {\n      const scale = this.params.bark.textureScale;\n      this.branchesMesh.material.aoMap = loadTexture(textures.bark[this.params.bark.type].ao, scale);\n      this.branchesMesh.material.map = loadTexture(textures.bark[this.params.bark.type].color, scale);\n      this.branchesMesh.material.normalMap = loadTexture(textures.bark[this.params.bark.type].normal, scale);\n      this.branchesMesh.material.roughnessMap = loadTexture(textures.bark[this.params.bark.type].roughness, scale);\n    }\n  }\n\n  /**\n   * Generates the geometry for the leaves\n   */\n  createLeavesGeometry() {\n    const g = new THREE.BufferGeometry();\n    g.setAttribute(\n      'position',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.verts), 3),\n    );\n    g.setAttribute(\n      'uv',\n      new THREE.BufferAttribute(new Float32Array(this.leaves.uvs), 2),\n    );\n    g.setIndex(\n      new THREE.BufferAttribute(new Uint16Array(this.leaves.indices), 1),\n    );\n    g.computeVertexNormals();\n    g.computeBoundingSphere();\n\n    const mat = new THREE.MeshStandardMaterial({\n      name: 'leaves',\n      color: this.params.leaves.tint,\n      side: THREE.DoubleSide,\n      alphaTest: this.params.leaves.alphaTest,\n    });\n\n    this.leavesMesh.geometry.dispose();\n    this.leavesMesh.geometry = g;\n    this.leavesMesh.material.dispose();\n    this.leavesMesh.material = mat;\n    this.leavesMesh.material.map = loadTexture(\n      textures.leaves[this.params.leaves.type],\n      new THREE.Vector2(1, 1),\n      THREE.SRGBColorSpace);\n\n    this.leavesMesh.castShadow = true;\n    this.leavesMesh.receiveShadow = true;\n  }\n}\n"],"names":["RNG","seed","__publicField","max","min","result","Branch","origin","THREE","orientation","length","radius","level","sectionCount","segmentCount","BarkType","Billboard","LeafType","TreeType","TreeParams","textureCache","textureLoader","loadTexture","path","scale","colorSpace","url","texture","Tree","params","branch","indexOffset","sectionOrientation","sectionOrigin","sectionLength","sections","i","sectionRadius","first","j","angle","vertex","normal","uv","gnarliness","qSection","qTwist","qForce","lastSection","count","radialOffset","childBranchStart","sectionIndex","sectionA","sectionB","alpha","childBranchOrigin","childBranchRadius","qA","qB","parentOrientation","radialAngle","q1","q2","q3","childBranchOrientation","childBranchLength","leafStart","leafOrigin","leafOrientation","leafSize","W","L","createLeaf","rotation","v","n","v1","v2","v3","v4","N","g","mat","textures.bark","textures.leaves"],"mappings":"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"}